---
layout: post
title:  "MDIO (SMI/MIIM)"
date:   2018-12-20 16:54:30 +0800
categories: [HW]
excerpt: MDIO/SMI/MIIM.
tags:
  - Bus
---

> [GitHub: MDIO](https://github.com/BiscuitOS/HardStack/tree/master/bus/MDIO)
>
> Email: BuddyZhang1 <buddy.zhang@aliyun.com>

# ç›®å½•

> 1. [ä¸“ä¸šæœ¯è¯­](#ä¸“ä¸šæœ¯è¯­)
>
> 2. [MDIO åŸç†](#MDIO åŸç†)
>
> 3. [Uboot ä¸­é€šè¿‡å·¥å…·è®¿é—® MDIO](#Uboot ä¸­é€šè¿‡å·¥å…·è®¿é—® MDIO)
>
> 4. [Uboot ä¸­é€šè¿‡æºç è®¿é—® MDIO](#Uboot ä¸­é€šè¿‡æºç è®¿é—® MDIO)
>
> 5. [Kernel ä¸­é€šè¿‡æºç è®¿é—® MDIO](#Kernel ä¸­é€šè¿‡æºç è®¿é—® MDIO)
>
> 6. [ç”¨æˆ·ç©ºé—´ä¸­é€šè¿‡å·¥å…·è®¿é—® MDIO](#ç”¨æˆ·ç©ºé—´ä¸­é€šè¿‡å·¥å…·è®¿é—® MDIO)
>
> 7. [ç”¨æˆ·ç©ºé—´ä¸­é€šè¿‡æºç è®¿é—® MDIO](#ç”¨æˆ·ç©ºé—´ä¸­é€šè¿‡æºç è®¿é—® MDIO)
>
> 8. [Arduino ä¸­é€šè¿‡æºç è®¿é—® MDIO](#Arduino ä¸­é€šè¿‡æºç è®¿é—® MDIO)
>
> 9. [é™„å½•](#é™„å½•)

-----------------------------------------------------

# <span id="ä¸“ä¸šæœ¯è¯­">ä¸“ä¸šæœ¯è¯­</span>

> MDIO: Management Data Input/Output.
>
> SMI: Serial Management Interface.
>
> MIIM: Media Independent Interface Management.
>
> MAC: Media Access Control.
>
> PHY: Ethernet physical layer.
>
> MII: Media Independent Interface.
>
> RMII: Reduced media-independent interface.
>
> GMII: Gigabit media-independent interface.
>
> RGMII: Reduced Gigabit media-independent interface.
>
> XGMII: 10-Gigabit media-independent interface.
>
> SGMII: Serial Gigabit media-independent interface.
>
> XAUI: 10 Gigabit Attachment Unit Interface.
>
> RXAUI: Reduced Pin eXtended Attachment Unit Interface.

------------------------------------------------

# <span id="MDIO åŸç†">MDIO åŸç†</span>

{% highlight ruby %}
+---------+                  +---------+                  +---------+
|         |                  |         |       MII        |         |
|   CPU   |<---------------->|   MAC   |<---------------->|   PHY   |
|         |                  |         |                  |         |
+---------+                  +---------+                  +---------+
{% endhighlight %}

### MII

MII æ˜¯ä¸€ä¸ªæ ‡å‡†æ¥å£ï¼Œç”¨äºè¿æ¥ MAC å’Œ PHYã€‚MII æ˜¯ IEEE-802.3 å®šä¹‰çš„ä»¥å¤ªç½‘æ ‡å‡†ï¼Œ
MII æ¥å£å¯ä»¥åŒæ—¶æ§åˆ¶å¤šä¸ª PHYã€‚

MII åŒ…å«ä¸¤ä¸ªæ¥å£ï¼š

> 1. ä¸€ä¸ªæ•°æ®æ¥å£ï¼Œç”¨æˆ· MAC å’Œ PHY ä¹‹é—´æ”¶å‘ Ethernet æ•°æ®
>
> 2. ä¸€ä¸ªç®¡ç†æ¥å£ï¼Œè¿™ä¸ªç®¡ç†æ¥å£é€šå¸¸ç§°ä¸º MDIOï¼ŒMIIM æˆ–è€… SMIã€‚è¿™ä¸ªæ¥å£ç”¨äº MAC 
>    ä» PHY è¯»å–ç›¸å…³ç®¡ç†å¯„å­˜å™¨çš„å€¼ï¼Œæˆ–è€…å¾€ PHY ç®¡ç†å¯„å­˜å™¨ä¸Šå†™å…¥æ•°æ®ã€‚

{% highlight ruby %}
      MAC                                              PHY
+--------------+                                 +--------------+
|              |                                 |              |
|              |       TX_ER/TX_EN/TXD[3:0]      |              |
|             -|-------------------------------->|    RX+/-     |
|              |                                 |              |
|   MII Data   |   RX_ER/RX_DV/RX_CLK/RXD[3:0]   |              |
|              |<--------------------------------|-   TX+/-     |
|              |          CRS/COL/TX_CLK         |              |
|              |<--------------------------------|-             |
+--------------+                                 +--------------+
|              |                                 |              |
|              |               MDC               |  Registers   |
|             -|-------------------------------->|              |
|     MIIM     |                                 |              |
|              |<------------------------------->|              |
|              |               MDIO              |              |
|              |                                 |              |
+--------------+                                 +--------------+
{% endhighlight %}

åŸå§‹çš„ MMI ä¼ è¾“ç½‘ç»œæ•°æ®éƒ¨åˆ†ä½¿ç”¨ä¸¤å¯¹ 4-bit çº¿ (4 æ ¹ç”¨äºå‘é€æ•°æ®ï¼Œ4 æ ¹ç”¨äºæ¥æ”¶æ•°
æ®)ï¼Œæ•°æ®åªæœ‰ 100 Mib/s çš„ååé‡ã€‚åœ¨åŸå§‹ MII åŸºç¡€ä¸Šï¼Œæ‹“å±•æ”¯æŒäº†è¡°å‡ä¿¡å·å’Œå¢åŠ 
é€Ÿåº¦ï¼Œå½“å‰å„ç§æ–°ä¼ è¾“æ¥å£ï¼šRMIIï¼ŒRGMIIï¼ŒXGMIIï¼ŒSGMIIã€‚è¿™äº›æ•°æ®ä¿¡å·æ¥å£è™½ç„¶é€Ÿåº¦
ç­‰æœ‰æ‰€æ”¹å˜ï¼Œä½† MMIM éƒ¨åˆ†è¿˜æ˜¯å…±åŒä½¿ç”¨ MIDO æ¥å£è¿›è¡Œç®¡ç†æ•°æ®çš„ä¼ è¾“ã€‚

### MDIO

MDIO ä¹Ÿè¢«ç§°ä¸º MIIMï¼Œæˆ–è€… SMIï¼Œå®ƒæ˜¯ IEEE802.3 å®šä¹‰æ ‡å‡† MII æ¥å£çš„ä¸€éƒ¨åˆ†ï¼Œç”¨äº 
MAC é…ç½® PHYã€‚MDIO å…·æœ‰ä¸¤ä¸ªä¿¡å·çº¿ï¼Œåˆ†åˆ«å¦‚ä¸‹ï¼š

> 1. MDC æ—¶é’Ÿçº¿ï¼šMDIO çš„æ—¶é’Ÿä¿¡å·ï¼Œç”± MAC é©±åŠ¨ PHY
>
> 2. MDIO æ•°æ®çº¿ï¼šåŒå‘æ•°æ®çº¿ï¼Œç”¨äºåœ¨ MAC å’Œ PHY ä¹‹é—´ä¼ è¾“é…ç½®ä¿¡æ¯


MDIO æ€»çº¿åªæ”¯æŒ MAC ä½œä¸ºä¸»è®¾å¤‡ï¼ŒPHY ä½œä¸ºä»è®¾å¤‡ã€‚MIDO æ”¯æŒä¸¤ç§æ—¶åºï¼Œåˆ†åˆ«ä¸º 
**Clause 22** å’Œ **Clause 45**.

##### MDIO clause 22

MDIO clause 22 æ˜¯ MDIO ä½¿ç”¨çš„ä¸€ç§ä¿¡å·æ—¶åºï¼Œåœ¨è¿™ä¸ªä¿¡å·æ—¶åºæ¨¡å¼ï¼ŒMAC å…ˆå‘ MDIO 
ä¿¡å·çº¿ä¸Šæ‹ 32 ä¸ªå‘¨æœŸï¼Œæ¥ç€ä¼ è¾“ 16 bit çš„æ§åˆ¶ä½ã€‚16 ä¸ªä¿¡å·ä½åŒ…å«äº†ä¸¤ä¸ªå¼€å§‹ä½ï¼Œ
2 ä¸ªè®¿é—®æ§åˆ¶ä½ï¼Œ5 bits çš„ PHY åœ°å€ï¼Œ5 bits çš„å¯„å­˜å™¨åœ°å€ï¼Œä»¥åŠ 2 bits çš„ç¿»è½¬ä½ã€‚
å½“è¿›è¡Œå†™æ“ä½œçš„æ—¶å€™ï¼ŒMAC åœ¨æ¥ä¸‹æ¥çš„å‘¨æœŸä¸­æä¾›åœ°å€å’Œæ•°æ®ï¼›å½“è¿›è¡Œè¯»æ“ä½œçš„æ—¶å€™ï¼Œ
PHY ä¼šç¿»è½¬ MDIO ä¹‹åå‘ MDIO ä¿¡å·çº¿ä¸Šå‘é€æ•°æ®ã€‚

MDIO Read

![MDIO_R](https://raw.githubusercontent.com/EmulateSpace/PictureSet/master/BiscuitOS/kernel/DEV000071.png)

MDIO Write

![MDIO_W](https://raw.githubusercontent.com/EmulateSpace/PictureSet/master/BiscuitOS/kernel/DEV000072.png)

##### MDIO Clause 45

MDIO ä¹Ÿæ”¯æŒ Clause 45 æ—¶åºï¼Œå…¶æ˜¯ Clause 22 çš„æ‹“å±•åè®®ã€‚ä¸ Clause 22 ä¸åŒçš„æ˜¯ï¼Œ
16 ä½ä¸­çš„èµ·å§‹ä½ï¼šClause 22 æ˜¯ 00ï¼Œ è€Œ Clause 45 æ˜¯ 01.

è¯¦ç»† MDIO Clause 45 å’Œ Clause 22 æ—¶åºï¼Œè¯·æŸ¥é˜…ï¼š

[äº†è§£ä¸MDIO/MDCæ¥å£ç›¸å…³çš„22å·ã€45å·æ¡æ¬¾](https://blog.csdn.net/rhythmwang/article/details/62039140)

[MDIO Clause 45 And Clause 22](https://blog.csdn.net/fengyunlian521/article/details/50969751)

-----------------------------------------------

# <span id="Uboot ä¸­é€šè¿‡å·¥å…·è®¿é—® MDIO">Uboot ä¸­è®¿é—® MDIO (SMI/MIIM)</span>

é¡¹ç›®å¼€å‘ä¸­ï¼Œç»å¸¸è¦åœ¨ uboot é˜¶æ®µé€šè¿‡ MDIO æ€»çº¿å»é…ç½® PHY æˆ–è€… SWITCHã€‚å¼€å‘è€…å¯
ä»¥å‚ç…§æœ¬èŠ‚å†…å®¹ï¼Œé€šè¿‡æºç æˆ–è€…å·¥å…·å»è®¿é—® MDIO æ€»çº¿ã€‚

## å·¥å…·è®¿é—® MDIO

uboot æä¾›äº† **mii** å·¥å…·å»æ“ä½œ MDIO æ€»çº¿ï¼Œç”¨æ³•å¦‚ä¸‹ï¼š

{% highlight ruby %}
mii - MII utility commands                                                                                
Usage:
mii device                            - list available devices
mii device <devname>                  - set current device
mii info   <addr>                     - display MII PHY info
mii read   <addr> <reg>               - read  MII PHY <addr> register <reg>
mii write  <addr> <reg> <data>        - write MII PHY <addr> register <reg>
mii modify <addr> <reg> <data> <mask> - modify MII PHY <addr> register <reg>
                                        updating bits identified in <mask>
mii dump   <addr> <reg>               - pretty-print <addr> <reg> (0-5 only)
{% endhighlight %}

#### åˆ—å‡ºå¯ç”¨çš„ç½‘å¡

**mii device** å‘½ä»¤å¯ä»¥åˆ—å‡ºæ‰€æœ‰å¯ç”¨çš„ç½‘å¡ï¼Œå‘½ä»¤æ¨¡å¼å¦‚ä¸‹ï¼š

{% highlight ruby %}
mii device
{% endhighlight %}

ä¾‹å¦‚ï¼ŒSoc ä¸Šå¯ç”¨çš„ç½‘å¡ï¼š

{% highlight ruby %}
ZynqMP> mii device
MII devices: 'eth0'
Current device: 'eth0'
ZynqMP>
{% endhighlight %}

#### åˆ—å‡º PHY ä¿¡æ¯

å½“æ‰¾æ‰“å¯ç”¨çš„ç½‘å¡ä¹‹åï¼Œå¯ä»¥ä½¿ç”¨ â€œmii infoâ€ å‘½ä»¤æŸ¥çœ‹ PHY ç›¸å…³çš„ä¿¡æ¯ï¼Œå‘½ä»¤æ¨¡å¼å¦‚
ä¸‹ï¼š

{% highlight ruby %}
ZynqMP> mii info 0
PHY 0x00: OUI = 0x5043, Model = 0x1D, Rev = 0x01, 1000baseT, FDX
ZynqMP>
{% endhighlight %}

#### MDIO è¯»

**mii read** å‘½ä»¤å¯ä»¥è¿›è¡Œ MDIO è¯»æ“ä½œï¼Œè¯¥æ“ä½œå¯ä»¥è®¿é—® PHY æˆ– SWITCH çš„å¯„å­˜å™¨ï¼Œ
å‘½ä»¤æ¨¡å¼å¦‚ä¸‹ï¼š

{% highlight ruby %}
mii read <phy_id> <reg_id>
{% endhighlight %}

ä¾‹å¦‚ï¼ŒSoc çš„ MDIO 0 æ€»çº¿ä¸ŠåŒ…å«ä¸€ä¸ª MV88e6185 PHYï¼ŒPHY ID å¯„å­˜å™¨åœ°å€ä¸º 0x2 å’Œ 
0x3ï¼Œé€šè¿‡ mii å·¥å…·è¯»æ“ä½œå¦‚ä¸‹ï¼š

{% highlight ruby %}
ZynqMP> mii read 0 0x3
0DD1
ZynqMP> mii read 0 0x2
0141
ZynqMP>
{% endhighlight %}

#### MDIO å†™

**mii write** å‘½ä»¤å¯ä»¥è¿›è¡Œ MDIO å†™æ“ä½œï¼Œè¯¥æ“ä½œå¯ä»¥å†™ PHY æˆ– SWITCH çš„å¯„å­˜å™¨ï¼Œ
å‘½ä»¤æ¨¡å¼å¦‚ä¸‹ï¼š

{% highlight ruby %}
mii write <phy_id> <reg_id> <data>
{% endhighlight %}

ä¾‹å¦‚ï¼Œå‘ MDIO 0 ä¸Šï¼ŒPHY 0 çš„ 0x16 å¯„å­˜å™¨å†™å€¼ï¼Œè¯¥å¯„å­˜å™¨æ˜¯åˆ‡é¡µå¯„å­˜å™¨ï¼š

{% highlight ruby %}
ZynqMP> mii read 0 0x16                                                         
0000                                                                            
ZynqMP> mii write 0 0x16 0x1                                                    
ZynqMP> mii read 0 0x16                                                         
0001                                                                            
ZynqMP>
{% endhighlight %}

# <span id="Uboot ä¸­é€šè¿‡æºç è®¿é—® MDIO">Uboot æºç è®¿é—® MDIO</span>

æœ‰æ—¶é¡¹ç›®éœ€æ±‚ï¼Œéœ€è¦åœ¨ uboot æºç ä¸­è®¿é—® MDIOï¼Œå¼€å‘è€…å¯ä»¥å‚è€ƒä¸‹é¢ä»£ç è¿›è¡Œ MDIO 
æ“ä½œï¼š

{% highlight ruby %}
/*
* MDIO (SMI/MIIM) read/write on Uboot
*
* (C) 2018.12.20 BiscuitOS <buddy.zhang@aliyun.com>
*
* This program is free software; you can redistribute it and/or modify
* it under the terms of the GNU General Public License version 2 as
* published by the Free Software Foundation.
*/
#include <common.h>
#include <miiphy.h>

/*
* MDIO read
*  @phy: PHY ID
*  @reg: Register address.
*  @data: read buffer.
*
* If succeed, return 0.
*/
static int mdio_read(unsigned char phy, unsigned char reg,
                                             unsigned short *data)
{
    const char *devname;

    /* use current device */
    devname = miiphy_get_current_dev();

    if (miiphy_read(devname, phy, reg, &data) != 0) {
        printf("Error reading from the PHY %d reg %d\n", phy, reg);
        return -1;
    }
    return 0;
}

/*
* MDIO write
*  @phy: PHY ID
*  @reg: Register address.
*  @data: data need to write.
*/
static int mdio_write(unsigned char phy, unsigned char reg,
                                              unsigned short data)
{
    const char *devname;

    /* use current device */
    devname = miiphy_get_current_dev();

    if (miiphy_write(devname, phy, reg, data) != 0) {
        printf("Error writing to the PHY %d reg %d\n", phy, reg);
        return -1;
    }
    return 0;
}
{% endhighlight %}

----------------------------------------------------

# <span id="Kernel ä¸­é€šè¿‡æºç è®¿é—® MDIO">Kernel ä¸­è®¿é—® MDIO</span>

å†…æ ¸ä¸­ MDIO çš„é©±åŠ¨ä¸€èˆ¬å’Œ PHY é©±åŠ¨æˆ–è€…ç½‘å¡é©±åŠ¨ä¸€åŒä½¿ç”¨ï¼Œå¼€å‘è€…å¯ä»¥å‚è€ƒä¸‹é¢é©±åŠ¨
æ¨¡å‹æ¥ä½¿ç”¨ MDIO

{% highlight ruby %}
/*
* MDIO/SMI/MIIM on Kernel
*
* (C) 2018.12.20 BuddyZhang1 <buddy.zhang@aliyun.com>
*
* This program is free software; you can redistribute it and/or modify
* it under the terms of the GNU General Public License version 2 as
* published by the Free Software Foundation.
*/
#include <linux/kernel.h>
#include <linux/init.h>
#include <linux/module.h>
#include <linux/mii.h>
#include <linux/phy.h>
#include <linux/phy_fixed.h>

#define MII_BUS         "mii_demo"

static struct mii_bus *mii_demo;

extern int swphy_read_reg(int reg, const struct fixed_phy_status *state);

/* mdio read entence */
static int mii_demo_read(struct mii_bus *bus, int phys_addr, int reg)
{
    struct fixed_phy_status state;

    /* setup real MDIO control register and transfer data */

    return swphy_read_reg(reg, &state);
}

/* mdio write entence */
static int mii_demo_write(struct mii_bus *bus, int phy_addr, int reg,
                                 unsigned short val)
{
    return 0;
}

static int __init mdio_demo_init(void)
{
    int ret;

    /* Allocate MII bus */
    mii_demo = mdiobus_alloc();
    if (mii_demo == NULL) {
        ret = -ENOMEM;
        goto err;
    }

    /* setup mii bus */
    snprintf(mii_demo->id, MII_BUS_ID_SIZE, "mii_demo-0");
    mii_demo->name  = MII_BUS;
    mii_demo->read  = &mii_demo_read;
    mii_demo->write = &mii_demo_write;

    /* Register mdio bus */
    ret = mdiobus_register(mii_demo);
    if (ret)
        goto err_alloc;   

    return 0;

err_alloc:
    mdiobus_free(mii_demo);

err:
    return ret;
}

static void __exit mdio_demo_exit(void)
{
    mdiobus_unregister(mii_demo);

    mdiobus_free(mii_demo);    
}

module_init(mdio_demo_init);
module_exit(mdio_demo_exit);
MODULE_LICENSE("GPL v2");
{% endhighlight %}

Makefile

{% highlight ruby %}
obj-m += mdio.o

KERNELDIR ?= /lib/modules/$(shell uname -r)/build

PWD       := $(shell pwd)

ROOT := $(dir $(M))
DEMOINCLUDE := -I$(ROOT)../include -I$(ROOT)/include

GCCVERSION = $(shell gcc -dumpversion | sed -e 's/\.\([0-9][0-9]\)/\1/g' -e 's/\.\([0-9]\)/0\1/g' -e 's/^[0-9]\{3,4\}$$/&00/')

GCC49 := $(shell expr $(GCCVERSION) \>= 40900)

all:
        $(MAKE) -C $(KERNELDIR) M=$(PWD) modules

install: all
        $(MAKE) -C $(KERNELDIR) M=$(PWD) modules_install
        depmod -a

clean:
        rm -rf *.o *.o.d *~ core .depend .*.cmd *.ko *.ko.unsigned *.mod.c .tmp_versions *.symvers \
        .cache.mk *.save *.bak Modules.* modules.order Module.markers *.bin

CFLAGS_mdio.o := -Wall $(DEMOINCLUDE)

ifeq ($(GCC49),1)
        CFLAGS_mdio.o += -Wno-error=date-time
endif

CFLAGS_mdio.o := $(DEMOINCLUDE)
{% endhighlight %}

ä¸Šè¿°æºç å¯ä»¥ä¹‹é—´ç¼–è¯‘åˆ°å†…æ ¸æºç æ ‘æˆ–å¤–éƒ¨ç¼–è¯‘ï¼Œå¤–éƒ¨ç¼–è¯‘é€‚ç”¨å¦‚ä¸‹å‘½ä»¤ï¼š

{% highlight ruby %}
make clean
make 
sudo insmod mdio.ko
{% endhighlight %}

#### MDIO é©±åŠ¨æ¨¡å‹åˆ†æ

å†…æ ¸ä¸º MDIO å­ç³»ç»Ÿæä¾›äº†ä»¥ä¸‹æ¥å£ä¾› MDIO çš„åˆ†é…ï¼Œæ³¨å†Œï¼Œé‡Šæ”¾ï¼Œå’Œé”€æ¯çš„æ“ä½œã€‚å½“ 
MDIO æ³¨å†ŒæˆåŠŸï¼Œç½‘å¡æˆ– CPU çš„ MAC å°±å¯ä»¥é€šè¿‡ MDIO æ€»çº¿å»é…ç½® PHY æˆ–è€… SWITCHã€‚

> 1. mdiobus_alloc() åˆ†é…ä¸€ä¸ª mdio bus ç»“æ„
>
> 2. mdiobus_free() é‡Šæ”¾ä¸€ä¸ª mdio bus
>
> 3. mdiobus_register() æ³¨å†Œä¸€ä¸ª mdio bus
>
> 4. mdiobus_unregister() æ³¨é”€ä¸€ä¸ª mdio bus

-------------------------------------------------------

# <span id="ç”¨æˆ·ç©ºé—´ä¸­é€šè¿‡å·¥å…·è®¿é—® MDIO">ç”¨æˆ·ç©ºé—´å·¥å…·è®¿é—® MDIO (SMI/MIIM)</span>

ç”¨æˆ·ç©ºé—´æä¾›äº†å¤šä¸ªå·¥å…·æ“ä½œ PHYï¼Œä¾‹å¦‚ **mii-diag**, **mii-tool** å’Œ 
**ethtool**ï¼Œè¿™äº›å·¥å…·éƒ½å¯ä»¥æ“ä½œä¸€ä¸ªå¯ç”¨çš„ PHYã€‚ä½¿ç”¨å¦‚ä¸‹ï¼š

#### mii-diag

{% highlight ruby %}
# mii-diag --help
Usage: mii-diag [-aDfrRvVw] [-AF <speed+duplex>] [--watch] <interface>.

  This program configures and monitors the transceiver management registers
  for network interfaces.  It uses the Media Independent Interface (MII)
  standard with additional Linux-specific controls to communicate with the
  underlying device driver.  The MII registers control and report network
  link settings and errors.  Examples are link speed, duplex, capabilities
  advertised to the link partner, status LED indications and link error
  counters.

   The common usage is
      mii-diag eth0

   The default interface is "eth0".
Frequently used options are
   -A  --advertise <speed|setting>
   -F  --fixed-speed <speed>
        Speed is one of: 100baseT4, 100baseTx, 100baseTx-FD, 100baseTx-HD,
                         10baseT, 10baseT-FD, 10baseT-HD
   -s  --status     Return exit status 2 if there is no link beat.

Less frequently used options are
   -a  --all-interfaces  Show the status all interfaces
              (Not recommended with options that change settings.)
   -D  --debug
   -g  --read-parameters        Get driver-specific parameters.
   -G  --set-parameters PARMS   Set driver-specific parameters.
       Parameters are comma separated, missing elements retain existing value.
   -M  --msg-level LEVEL        Set the driver message bit map.
   -p  --phy ADDR               Set the PHY (MII address) to report.
   -r  --restart        Restart the link autonegotiation.
   -R  --reset          Reset the transceiver.
   -v  --verbose        Report each action taken.
   -V  --version        Emit version information.
   -w  --watch          Continuously monitor the transceiver and report changes.

   This command returns success (zero) if the interface information can be
   read.  If the --status option is passed, a zero return means that the
   interface has link beat.
{% endhighlight %}

#### mii-tool

{% highlight ruby %}
mii-tool --help
usage: mii-tool [-VvRrwl] [-A media,... | -F media] [interface ...]
       -V, --version               display version information
       -v, --verbose               more verbose output
       -R, --reset                 reset MII to poweron state
       -r, --restart               restart autonegotiation
       -w, --watch                 monitor for link status changes
       -l, --log                   with -w, write events to syslog
       -A, --advertise=media,...   advertise only specified media
       -F, --force=media           force specified media technology
media: 1000baseTx-HD, 1000baseTx-FD,
       100baseT4, 100baseTx-FD, 100baseTx-HD,
       10baseT-FD, 10baseT-HD,
       (to advertise both HD and FD) 1000baseTx, 100baseTx, 10baseT
{% endhighlight %}

#### ethtool

{% highlight ruby %}
ethtool --help
{% endhighlight %}

# <span id="ç”¨æˆ·ç©ºé—´ä¸­é€šè¿‡æºç è®¿é—® MDIO">ç”¨æˆ·ç©ºæºç é—´è®¿é—® MDIO (SMI/MIIM)</span>

ç”¨æˆ·ç©ºé—´åœ¨æºç ä¸­ç›´æ¥è®¿é—® MDIO çš„æ–¹æ³•æ¯”è¾ƒéš¾æ‰¾ï¼Œä½†è¿™é‡Œæä¾›äº†ä¸€ä¸ªæ€è·¯ï¼Œå¼€å‘è€…å¯ä»¥
å‚ç…§è¿™ä¸ªæºç ï¼Œå°±å¯ä»¥åœ¨ç”¨æˆ·ç©ºé—´æ“ä½œ MDIO æ€»çº¿ã€‚

é¦–å…ˆï¼Œå¼€å‘è€…å¯ä»¥ç¼–è¯‘ä¸€ä¸ªå†…æ ¸é©±åŠ¨ï¼Œç„¶åè¿™ä¸ªé©±åŠ¨å°† MDIO æ€»çº¿å¯¼å‡ºåˆ°ç”¨æˆ·ç©ºé—´ï¼Œæºç 
å¦‚ä¸‹ï¼š

{% highlight ruby %}
/*
* MDIO Userland Procedure-Interface
*
* (C) 2018.12.20 BuddyZhang1 <buddy.zhang@aliyun.com>
*
* This program is free software; you can redistribute it and/or modify
* it under the terms of the GNU General Public License version 2 as
* published by the Free Software Foundation.
*/
#include <linux/init.h>
#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/device.h>
#include <linux/stat.h>
#include <linux/slab.h>
#include <linux/platform_device.h>

#include <linux/err.h>
#include <linux/io.h>
#include <asm/uaccess.h>
#include <linux/bitops.h>
#include <linux/phy.h>

#define DEV_NAME "mdio_demo"

/* mdio_demo from real Ethernet card, and export it here! */
extern struct mii_bus *mdio_demo;

/* Parse input string
*  Value[0]: DeviceAddress. Value[1]: Register. Value[2]: date in Byte.
*  
*  Read/Write operation
*  CMD: <r/w>,<DevAddr>,<RegAddr>,[Value],
*       r: Read special PHY/SERDES register
*       w: Write data to special PHY/SERDES register.
*       DevAddr: Device address
*       RegAddr: Register address
*       Value:   value what to write.
*/
static int parse_input_string(const char *string, int *value, int *flag)
{
    int nr;
    char *tmp;
    char *buffer, *leg;
    int i = 0;

    buffer = (char *)kmalloc(strlen(string) + 1, GFP_KERNEL);
    leg = buffer;
    memset(buffer, 0, strlen(string) + 1);
    /* Copy original data */
    strcpy(buffer, string);

    while ((tmp = strstr(buffer, ","))) {
        int data;
        char dd[20];

        nr = tmp - buffer;
        tmp++;
        strncpy(dd, buffer, nr);
        dd[nr] = '\0';
        if (strncmp(dd, "r", 1) == 0) {
            *flag = 1;
        } else if (strncmp(dd, "w", 1) == 0) {
            *flag = 2;
        } else {
            sscanf(dd, "%d", &data);
            value[i++] = data;
        }
        buffer = tmp;
    }
    kfree(leg);
    return 0;
}

/* Dump all PHY's all register */
static ssize_t mdio_demo_show(struct device *dev,
                    struct device_attribute *attr, char *buf)
{
    ssize_t size = 0;
    int phy, reg;

    for (phy = 0; phy < 32; phy++) {
        for (reg = 0; reg < 32; reg++) {
            unsigned short val;

            if (((reg % 16) == 0) && (reg != 0))
                printk("\n");
            val = mdio_demo->read(mdio_demo, phy, reg);
            printk("%#04x ", val);
        }
    }
    printk("\n");

    return size;
}

/* Read/Write PHY register */
static ssize_t mdio_demo_store(struct device *dev,
            struct device_attribute *attr, const char *buf, size_t size)
{
    int flag = 0; /* 1: read 2: write */
    int value[10];

    parse_input_string(buf, value, &flag);
    /* Read data from Port-Register */
    if (flag == 1) {
        unsigned short reg;

        reg = mdio_demo->read(mdio_demo, value[0], value[1]);
        /* Output message into dmesg */
        printk("\r\nRead: Port - Dev[%#x] Reg[%#x] Value[%#x]\n",
                                              value[0], value[1], reg);
    } else if (flag == 2) { /* Write data to Port-Register */

        mdio_demo->write(mdio_demo, value[0], value[1], value[2]);
        /* Output message into dmesag */
        printk("\r\nWrite: Port - Dev[%#x] Reg[%#x] value[%#x]\n",
                                          value[0], value[1], value[2]);
    } else {
        printk(KERN_ERR "Unknown operation from Port register\n");
    }
    return size;
}

static struct device_attribute mdio_demo_attr =
       __ATTR_RW(mdio_demo);

/* probe platform driver */
static int mdio_demo_probe(struct platform_device *pdev)
{
    int err;

    err = device_create_file(&pdev->dev, &mdio_demo_attr);
    if (err) {
        printk("Unable to create device file for reg***.\n");
        return -EINVAL;
    }

    return 0;
}

/* remove platform driver */
static int mdio_demo_remove(struct platform_device *pdev)
{
    device_remove_file(&pdev->dev, &mdio_demo_attr);

    return 0;
}

/* platform device information */
static struct platform_device mdio_demo_device = {
    .name = DEV_NAME,  /* Same as driver name */
    .id   = -1,
};

/* platform driver information */
static struct platform_driver mdio_demo_driver = {
    .probe  = mdio_demo_probe,
    .remove = mdio_demo_remove,
    .driver = {
        .name = DEV_NAME, /* Same as device name */
    },
};

/* init entence */
static __init int mdio_demo_init(void)
{
    int ret;


    /* register device */
    ret = platform_device_register(&mdio_demo_device);
    if (ret)
        return ret;    
    
    /* register driver */
    return platform_driver_register(&mdio_demo_driver);
}

/* Exit entence */
static __exit void mdio_demo_exit(void)
{
    platform_driver_unregister(&mdio_demo_driver);
    platform_device_unregister(&mdio_demo_device);
}

module_init(mdio_demo_init);
module_exit(mdio_demo_exit);

MODULE_LICENSE("GPL v2");
{% endhighlight %}

Makefile

{% highlight ruby %}
obj-m += mdio.o

KERNELDIR ?= /lib/modules/$(shell uname -r)/build

PWD       := $(shell pwd)

ROOT := $(dir $(M))
DEMOINCLUDE := -I$(ROOT)../include -I$(ROOT)/include

GCCVERSION = $(shell gcc -dumpversion | sed -e 's/\.\([0-9][0-9]\)/\1/g' -e 's/\.\([0-9]\)/0\1/g' -e 's/^[0-9]\{3,4\}$$/&00/')

GCC49 := $(shell expr $(GCCVERSION) \>= 40900)

all:
        $(MAKE) -C $(KERNELDIR) M=$(PWD) modules

install: all
        $(MAKE) -C $(KERNELDIR) M=$(PWD) modules_install
        depmod -a

clean:
        rm -rf *.o *.o.d *~ core .depend .*.cmd *.ko *.ko.unsigned *.mod.c .tmp_versions *.symvers \
        .cache.mk *.save *.bak Modules.* modules.order Module.markers *.bin

CFLAGS_mdio.o := -Wall $(DEMOINCLUDE)

ifeq ($(GCC49),1)
        CFLAGS_mdio.o += -Wno-error=date-time
endif

CFLAGS_mdio.o := $(DEMOINCLUDE)
{% endhighlight %}

å°†ä¸Šé¢çš„æºç ç¼–è¯‘è¿›å†…æ ¸ä¹‹åï¼Œå¼€å‘è€…å¯ä»¥åœ¨ç”¨æˆ·ç©ºé—´æŒ‰å¦‚ä¸‹æ–¹æ³•å¯¹ MDIO è¿›è¡Œè¯»å†™æ“
ä½œã€‚

#### MDIO è¯»

MDIO è¯»å‘½ä»¤æ ¼å¼å¦‚ä¸‹ï¼š

{% highlight ruby %}
echo "r,<phy_id>,<reg_id>," > /sys/devices/platform/mdio_demo/mdio_demo_reg
dmesg | tail -n 5
{% endhighlight %}

ä¾‹å¦‚ï¼Œä» PHY 0 ä¸Šè¯»å– ID å¯„å­˜å™¨

{% highlight ruby %}
# echo "r,0x0,0x2," > /sys/devices/platform/mdio_demo/mdio_demo_reg
# dmesg | tail -n 5

Read: Port - Dev[0x0000] Reg[0x0002] Value[0x0141]

{% endhighlight %}

#### MDIO å†™

MDIO å†™å‘½ä»¤æ ¼å¼å¦‚ä¸‹ï¼š

{% highlight ruby %}
echo "w,<phy_id>,<reg_id>,<data>," > /sys/devices/platform/mdio_demo/mdio_demo_reg
dmesg | tail -n 5
{% endhighlight %}

ä¾‹å¦‚ï¼Œå¾€ PHY 0 çš„ 22 å·å¯„å­˜å™¨ä¸Šå†™å€¼

{% highlight ruby %}
# echo "r,0x0,0x16," > /sys/devices/platform/mdio_demo/mdio_demo_reg
# echo "w,0x0,0x16,0x48," > /sys/devices/platform/mdio_demo/mdio_demo_reg
# echo "r,0x0,0x16," > /sys/devices/platform/mdio_demo/mdio_demo_reg
# dmesg | tail -n 10

Read: Port - Dev[0x0000] Reg[0x0016] Value[0x0000]

Write: Port - Dev[0x0000] Reg[0x0016] Value[0x0048]

Read: Port - Dev[0x0000] Reg[0x0016] Value[0x0048]
{% endhighlight %}

#### Dump æ“ä½œ

å°†æ‰€æœ‰ PHY çš„æ‰€æœ‰å¯„å­˜å™¨éƒ½ Dump å‡ºæ¥ï¼Œå‘½ä»¤æ¨¡å¼å¦‚ä¸‹ï¼š

{% highlight ruby %}
cat /sys/devices/platform/mdio_demo/mdio_demo_reg
{% endhighlight %}

--------------------------------------------

# <span id="Arduino ä¸­é€šè¿‡æºç è®¿é—® MDIO">Arduino ä¸Šè®¿é—® MDIO</span>

Arduino ä¸Šè®¿é—® MDIO çš„æ–¹æ³•å¯ä»¥æ‹“å±•åˆ° MCU ä¸Šè®¿é—® MDIO çš„æ–¹æ³•ã€‚è¿™é‡Œä½¿ç”¨ç¡¬ä»¶çš„æ–¹
å¼ï¼Œé€šè¿‡ç›´æ¥æ‹å‘¨æœŸä¿¡å·äº§ç”Ÿ MDIO çš„è¯»å†™æ—¶åºã€‚å¼€å‘è€…å¯ä»¥å‚ç…§å¦‚ä¸‹ä»£ç ï¼š

{% highlight ruby %}
/*
* MDIO/SMI/MIIM on Arduino
*
* (C) 2018.12.20 BuddyZhang1 <buddy.zhang@aliyun.com>
* (C) Sword <xxx@jjj.com>
*
* This program is free software; you can redistribute it and/or modify
* it under the terms of the GNU General Public License version 2 as
* published by the Free Software Foundation.
*/
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>

#define DIR    4 // 74HCT245 Dir
#define MDC    3 // D3 PIN for MDC
#define MDIO   2 // D2 PIN for MDIO
#define OUT    1
#define IN     0

int smi_init(void)
{
    pinMode(DIR, OUTPUT);
    digitalWrite(DIR, OUT);     //245 A to Y
    pinMode(MDC, OUTPUT);
    pinMode(MDIO, OUTPUT);
    return 0;
}


/*! Generates a rising edge pulse on MDC */
void pulse_mdc(void)
{
    volatile uint8_t i;
    //pinMode(MDC, OUTPUT);
    //i++;
    digitalWrite(MDC, 0);
    //delay(1);  change from 1Kbit/s to 10Kbit/s
    delayMicroseconds(100);
    i++;
    digitalWrite(MDC, 1);
    //delay(1);
    delayMicroseconds(100);
    i++;
}

/*
* SMI/MDIO/MIIM write
*  @phy: PHY id
*  @reg: Register address.
*  @data: data need to write.
*/
void write_smi(uint8_t phy, uint8_t reg, uint16_t data)
{
    uint8_t byte;
    uint16_t word;

    /* MDIO pin is output */
    digitalWrite(DIR, OUT);
    pinMode(MDIO, OUTPUT);

    digitalWrite(MDIO, 1);
    digitalWrite(MDC, 1);
    for (byte = 0;byte < 32; byte++)
        pulse_mdc();

    /* Stat code */
    digitalWrite(MDIO, 0);
    pulse_mdc();
    digitalWrite(MDIO, 1);
    pulse_mdc();

    /* Write OP Code */
    digitalWrite(MDIO, 0);
    pulse_mdc();
    digitalWrite(MDIO, 1);
    pulse_mdc();

    /* PHY address - 5 bits */
    for (byte = 0x10; byte != 0; byte = byte >> 1) {
        if (byte & phy)
            digitalWrite(MDIO, 1);
        else
            digitalWrite(MDIO, 0);
        pulse_mdc();
    }

    /* REG address - 5 bits */
    for (byte = 0x10; byte != 0; byte = byte >> 1) {
        if (byte & reg)
            digitalWrite(MDIO, 1);
        else
            digitalWrite(MDIO, 0);

        pulse_mdc();
    }
    /* Turn around bits */
    digitalWrite(MDIO, 1);
    pulse_mdc();
    digitalWrite(MDIO, 0);
    pulse_mdc();

    /* Data - 16 bits */
    for(word = 0x8000; word != 0; word = word >> 1) {
        if (word & data)
            digitalWrite(MDIO, 1);
        else
            digitalWrite(MDIO, 0);

        pulse_mdc();
    }

    /* This is needed for some reason... */
    pulse_mdc();
    /* Stay in 0 state */
    //MDC = 0;
    digitalWrite(DIR, IN);
    pinMode(MDIO, INPUT);
}

/*
* SMI/MDIO/MIIM read
*  @phy: PHY id.
*  @reg: Register address.
*/
uint16_t read_smi(uint8_t phy, uint8_t reg)
{
    uint8_t byte;
    volatile uint16_t word, data;
    data = 0;

    /* MDIO pin is output */
    digitalWrite(DIR, OUT);
    pinMode(MDIO, OUTPUT);

    digitalWrite(MDIO, 1);
    digitalWrite(MDC, 1);
    for (byte = 0; byte < 32; byte++)
        pulse_mdc();

    /* Stat code */
    digitalWrite(MDIO, 0);
    pulse_mdc();
    digitalWrite(MDIO, 1);
    pulse_mdc();

    /* Read OP Code */
    digitalWrite(MDIO, 1);
    pulse_mdc();
    digitalWrite(MDIO, 0);
    pulse_mdc();

    /* PHY address - 5 bits */
    for (byte = 0x10; byte != 0; ) {
        if (byte & phy) {
            digitalWrite(MDIO, 1);
            pulse_mdc();
        } else {
            digitalWrite(MDIO, 0);
            pulse_mdc();
        }
        byte = byte >> 1;
    }

    /* REG address - 5 bits */
    for (byte = 0x10; byte != 0; ){
        if (byte & reg){
            digitalWrite(MDIO, 1);
            pulse_mdc();
        }else{
            digitalWrite(MDIO, 0);
            pulse_mdc();
        }
        byte = byte >> 1;
    }

    /* Turnaround bits */

    /* MDIO now is input */
    digitalWrite(DIR, IN);
    pinMode(MDIO, INPUT);
    pinMode(MDC, OUTPUT);
    pulse_mdc();
    pulse_mdc();

    /* Data - 16 bits */
    for(word = 0x8000; word != 0; ) {

        if (digitalRead(MDIO)) {
            data |= word;
        }
        pulse_mdc();
        word = word >> 1;
    }

    /* This is needed for some reason... */
    pulse_mdc();
    /* Stay in 0 state */
    //MDC = 0;
    digitalWrite(DIR, IN);
    pinMode(MDIO, INPUT);

    return data;
}

/* setup entence */
void setup()
{
    uint8_t phy, reg, val, i, sel;
    String inStr = "";
    uint16_t reg_val = 0;
  
    /* start serial port at 9600 bps: */
    Serial.begin(9600);
    Serial.print("MDIO (SMI/MIIM) Initialization ....\n");
    smi_init();
    for(;;){
        Serial.print("===========================================\r\n");
        Serial.print("Arduino MDIO (SMI/MIIM) Bus tools\r\n");
        Serial.print("1. Read register\r\n");
        Serial.print("2. Write register\r\n");
        Serial.print("3. Dump register\r\n");

        Serial.setTimeout(100000);
        sel = Serial.parseInt();

        switch(sel) {
        case 1:
            Serial.print("Read-PHY: ");
            Serial.setTimeout(100000);
            phy = Serial.parseInt();
            Serial.print(phy);
            if (phy > 31)
                break;
            Serial.print(" Register: ");
            Serial.setTimeout(100000);
            reg = Serial.parseInt();
            Serial.print(reg);
            if (reg > 31)
                break;
            reg_val = read_smi(phy, reg);
            Serial.print("\n\r\n\rRead-PHY: ");
            Serial.print(phy);
            Serial.print(" Register: ");
            Serial.print(reg);
            Serial.print(" Value [0x");
            Serial.print(reg_val, HEX);
            Serial.print("]\r\n\r\n");
            break;
        case 2:
            Serial.print("Write-PHY: ");
            Serial.setTimeout(100000);
            phy = Serial.parseInt();
            Serial.print(phy);
            if (phy > 31)
                break;
            Serial.print(" Register: ");
            Serial.setTimeout(100000);
            reg = Serial.parseInt();
            Serial.print(reg);
            if (reg > 31)
                break;
            Serial.print(" Value: ");
            reg_val = Serial.parseInt();
            Serial.print(reg_val, HEX);
            write_smi(phy, reg, reg_val);
            Serial.print("\n\r\n\rWrite Port: ");
            Serial.print(phy);
            Serial.print(" Register: ");
            Serial.print(reg);
            Serial.print(" Value [0x");
            Serial.print(reg_val, HEX);
            Serial.print("]\r\n\r\n");
            break;
        case 3:
            Serial.print("Dump Start PHY: ");
            phy = Serial.parseInt();
            Serial.print(phy);
            Serial.print(" End PHY: ");
            Serial.setTimeout(100000);
            i = Serial.parseInt();
            Serial.print(i);
            Serial.print("\r\n");
            for (; phy < i; phy++) {
                Serial.print("/*0x");
                Serial.print(phy, HEX);
                Serial.print("*/");
                Serial.print("{");
                for (reg = 0; reg < 32; reg++) {
                    Serial.print("0x");
                    reg_val = read_smi(phy, reg);
                    Serial.print((reg_val & 0xffff), HEX);
                    if (reg < 31)
                        Serial.print(",");
                    delay(10);
                }
                Serial.print("}\r\n");
            }
            break;
        default:
            Serial.print("input wrong\r\n");
            break;
        }
    }
}

/* loop entence */
void loop()
{
}
{% endhighlight %}

Arduino å¯ä»¥ä½œä¸ºä¸€ä¸ª MDIOè°ƒè¯•å™¨ï¼ŒåŠ é€Ÿç½‘å¡ï¼ŒPHYï¼ŒSWITCH ç­‰å¤–éƒ¨è°ƒè¯•çš„é€Ÿåº¦ã€‚

--------------------------------------------------------

# <span id="é™„å½•">é™„å½•</span>

> [Media-independent interface](https://en.wikipedia.org/wiki/Media-independent_interface)
>
> [Management Data Input/Output](https://en.wikipedia.org/wiki/Management_Data_Input/Output)
>
> [MDIO Clause 22 and 45](www.ieee802.org/3/efm/public/nov02/oam/pannell_oam_1_1102.pdf)
>
> [BiscuitOS Home](https://biscuitos.github.io/)
>
> [BiscuitOS Driver](https://biscuitos.github.io/blog/BiscuitOS_Catalogue/)
>
> [BiscuitOS Kernel Build](https://biscuitos.github.io/blog/Kernel_Build/)
>
> [Linux Kernel](https://www.kernel.org/)
>
> [Bootlin: Elixir Cross Referencer](https://elixir.bootlin.com/linux/latest/source)

## èµèµä¸€ä¸‹å§ ğŸ™‚

![MMU](https://raw.githubusercontent.com/EmulateSpace/PictureSet/master/BiscuitOS/kernel/HAB000036.jpg)
