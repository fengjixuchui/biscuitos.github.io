---
layout: post
title:  "DMA"
date:   2018-12-18 16:56:30 +0800
categories: [HW]
excerpt: DMA.
tags:
  - Bus
---

> [GitHub: DMA](https://github.com/BiscuitOS/HardStack/tree/master/bus/DMA)
>
> Email: BuddyZhang1 <buddy.zhang@aliyun.com>

# ç›®å½•

> 1. [DMA åŸç†](#DMA åŸç†)
>
> 2. [Kernel ä¸­ä½¿ç”¨ DMA](#Kernel ä¸­ä½¿ç”¨ DMA)
>
> 3. [ç”¨æˆ·ç©ºé—´ä½¿ç”¨ DMA](#ç”¨æˆ·ç©ºé—´ä½¿ç”¨ DMA)
>
> 4. [DMA æ€§èƒ½æµ‹è¯•](#DMA æ€§èƒ½æµ‹è¯•)
>
> 5. [é™„å½•](#é™„å½•)

-------------------------------------------------------

# <span id="DMA åŸç†">DMA åŸç†</span>

![Menuconfig1](/assets/PDB/BiscuitOS/kernel/DEV000061.png)

DMA çš„åŸæ„ä¸º direct memory accessï¼Œä¹Ÿå°±æ˜¯ç›´æ¥å†…å­˜è®¿é—®(å¯ä»¥ç†è§£ä¸ºè¯»å†™)ã€‚DMA ä¼ 
è¾“å®é™…ä¸Šæ˜¯ DMA æ§åˆ¶å™¨å°†æ•°æ®ä»ä¸€ä¸ªè®¾å¤‡æ‹·è´åˆ°å¦ä¸€ä¸ªè®¾å¤‡çš„è¿‡ç¨‹ï¼ŒDMA æ§åˆ¶å™¨çš„åˆå§‹
åŒ–éœ€è¦ cpu å‚ä¸ï¼Œä½†æ˜¯æ•°æ®ä¼ è¾“è¿‡ç¨‹æ˜¯ä¸éœ€è¦ cpu å‚ä¸çš„ã€‚å®é™…ä¸Š DMA ä¸åªé€‚ç”¨äºæœ‰
å†…å­˜å‚ä¸ä¸‹çš„æ•°æ®ä¼ è¾“ï¼Œä¸‹è¡¨æ˜¯ DMA é€‚ç”¨çš„æ•°æ®ä¼ è¾“åœºæ™¯

> 1. å†…å­˜ to å†…å­˜
>
> 2. å†…å­˜ to å¤–å›´è®¾å¤‡
>
> 3. å¤–å›´è®¾å¤‡ to å†…å­˜
>
> 4. å¤–å›´è®¾å¤‡ to å¤–å›´è®¾å¤‡

## æ•°æ®ä¼ è¾“è¿‡ç¨‹

![Menuconfig1](/assets/PDB/BiscuitOS/kernel/DEV000062.png)

æœ‰ä¸¤ç§æ–¹å¼å¯ä»¥å¼•å‘ DMA æ•°æ®ä¼ è¾“ï¼šè½¯ä»¶å¯¹æ•°æ®çš„è¯·æ±‚ã€ç¡¬ä»¶å¼‚æ­¥åœ°å°†æ•°æ®ä¼ é€’ç»™ç³»ç»Ÿã€‚

#### è½¯ä»¶å¯¹æ•°æ®è¯·æ±‚ä¼ è¾“è¿‡ç¨‹

> 1. å½“è¿›ç¨‹è°ƒç”¨readï¼Œé©±åŠ¨ç¨‹åºå‡½æ•°åˆ†é…ä¸€ä¸ªDMAç¼“å†²åŒºï¼Œå¹¶è®©ç¡¬ä»¶å°†æ•°æ®ä¼ è¾“åˆ°è¿™ä¸ª
>    ç¼“å†²åŒºä¸­ï¼Œè¿›ç¨‹è¿›å…¥ç¡çœ çŠ¶æ€
>
> 2. ç¡¬ä»¶å°†æ•°æ®å†™å…¥åˆ° DMA ç¼“å†²åŒºï¼Œå†™å…¥å®Œæˆåäº§ç”Ÿä¸€ä¸ªä¸­æ–­(ç”± DMAC äº§ç”Ÿ)
>
> 3. ä¸­æ–­å¤„ç†ç¨‹åºè·å–åˆ°è¾“å…¥çš„æ•°æ®ï¼Œç„¶åå”¤é†’è¿›ç¨‹ï¼Œè¿›ç¨‹å¯ä»¥è¯»å–æ•°æ®


#### ç¡¬ä»¶å¼‚æ­¥æ•°æ®ä¼ è¾“è¿‡ç¨‹

> 1. ç¡¬ä»¶äº§ç”Ÿä¸­æ–­ï¼Œå®£å‘Šæ•°æ®çš„åˆ°æ¥
>
> 2. ä¸­æ–­å¤„ç†ç¨‹åºåˆ†é…ä¸€ä¸ªç¼“å†²åŒºï¼Œå¹¶ä¸”å‘Šè¯‰ç¡¬ä»¶å‘å“ªé‡Œä¼ è¾“æ•°æ®
>
> 3. å¤–å›´è®¾å¤‡å°†æ•°æ®å†™å…¥ç¼“å†²åŒºï¼Œå®Œæˆåäº§ç”Ÿå¦å¤–ä¸€ä¸ªä¸­æ–­
>
> 4. å¤„ç†ç¨‹åºåˆ†å‘æ–°æ•°æ®ï¼Œå”¤é†’ç›¸å…³è¿›ç¨‹ï¼Œæ‰§è¡Œç›¸åº”æ“ä½œ

ç½‘å¡æ•°æ®ä¼ è¾“å°±æ˜¯ä½¿ç”¨ç¡¬ä»¶å¼‚æ­¥æ•°æ®ä¼ è¾“æ–¹å¼ï¼Œåœ¨ä¸‹è½½ã€è®¿é—®çš„è¿‡ç¨‹ä¸­ï¼Œkernel å¹¶ä¸ç¡®
å®šæ•°æ®åˆ°æ¥çš„æ—¶é—´ã€‚ç½‘ç»œæ•°æ®æœ€å…ˆåˆ°è¾¾çš„æ˜¯ç¡¬ä»¶ç½‘å¡ï¼Œç½‘å¡æ¥æ”¶åˆ°ä¸€å®šé‡çš„ç½‘ç»œæ•°æ®æ—¶ï¼Œ
äº§ç”Ÿä¸­æ–­ï¼Œé€šè¿‡kernelå¤„ç†ï¼Œè¿›å…¥ç¡¬ä»¶å¼‚æ­¥æ•°æ®ä¼ è¾“è¿‡ç¨‹ã€‚

## æ•°æ®ä¸€è‡´æ€§é—®é¢˜

CPU å†™å†…å­˜çš„æ—¶å€™æœ‰ä¸¤ç§æ–¹å¼ï¼š

> 1. write through: CPU ç›´æ¥å†™å†…å­˜ï¼Œä¸ç»è¿‡ cacheã€‚
>
> 2. write back: CPU åªå†™åˆ° cache ä¸­ã€‚cache çš„ç¡¬ä»¶ä½¿ç”¨ LRU ç®—æ³•å°† cache é‡Œé¢çš„
>    å†…å®¹æ›¿æ¢åˆ°å†…å­˜ã€‚

DMA å¯ä»¥å®Œæˆä»å†…å­˜åˆ°å¤–è®¾ç›´æ¥è¿›è¡Œæ•°æ®æ¬ç§»ã€‚ä½† DMA ä¸èƒ½è®¿é—® CPU çš„ cacheï¼ŒCPU åœ¨
è¯»å†…å­˜çš„æ—¶å€™ï¼Œå¦‚æœ cache å‘½ä¸­åˆ™åªæ˜¯åœ¨cache å»è¯»ï¼Œè€Œä¸æ˜¯ä»å†…å­˜è¯»ï¼Œå†™å†…å­˜çš„æ—¶å€™ï¼Œ
ä¹Ÿå¯èƒ½å®é™…ä¸Šæ²¡æœ‰å†™åˆ°å†…å­˜ï¼Œè€Œåªæ˜¯ç›´æ¥å†™åˆ°äº† cacheã€‚è¿™æ ·ä¸€æ¥ï¼Œå¦‚æœ DMA ä»å°†æ•°æ®
ä»å¤–è®¾å†™åˆ°å†…å­˜ï¼ŒCPU ä¸­ cache ä¸­çš„æ•°æ®ï¼ˆå¦‚æœæœ‰çš„è¯ï¼‰å°±æ˜¯æ—§æ•°æ®äº†ï¼Œè¿™æ—¶ CPU åœ¨è¯»
å†…å­˜çš„æ—¶å€™å‘½ä¸­ cache äº†ï¼Œå°±æ˜¯è¯»åˆ°äº†æ—§æ•°æ®ï¼›CPU å†™æ•°æ®åˆ°å†…å­˜æ—¶ï¼Œå¦‚æœåªæ˜¯å…ˆå†™åˆ°
äº† cacheï¼Œåˆ™å†…å­˜é‡Œçš„æ•°æ®å°±æ˜¯æ—§æ•°æ®äº†ã€‚è¿™ä¸¤ç§æƒ…å†µï¼ˆä¸¤ä¸ªæ–¹å‘ï¼‰éƒ½å­˜åœ¨ cache ä¸€è‡´
æ€§é—®é¢˜ã€‚ä¾‹å¦‚ï¼Œç½‘å¡å‘åŒ…çš„æ—¶å€™ï¼ŒCPU å°†æ•°æ®å†™åˆ° cacheï¼Œè€Œç½‘å¡çš„ DMA ä»å†…å­˜é‡Œå»è¯»
æ•°æ®ï¼Œå°±å‘é€äº†é”™è¯¯çš„æ•°æ®ã€‚

å¦‚ä½•è§£å†³ä¸€è‡´æ€§é—®é¢˜

ä¸»è¦é ä¸¤ç±» APIsï¼š

> 1. ä¸€è‡´æ€§DMAç¼“å­˜(Coherent DMA buffers)
>
> 2. æµå¼DMAæ˜ å°„(DMA Streaming Mapping)

#### ä¸€è‡´æ€§DMAç¼“å­˜(Coherent DMA buffers)

DMA éœ€è¦çš„å†…å­˜ç”±å†…æ ¸å»ç”³è¯·ï¼Œå†…æ ¸å¯èƒ½éœ€è¦å¯¹è¿™æ®µå†…å­˜é‡æ–°åšä¸€éæ˜ å°„ï¼Œç‰¹ç‚¹æ˜¯æ˜ å°„çš„
æ—¶å€™æ ‡è®°è¿™äº›é¡µæ˜¯ä¸å¸¦ cache çš„ï¼Œè¿™ä¸ªç‰¹æ€§ä¹Ÿæ˜¯å­˜æ”¾åœ¨é¡µè¡¨é‡Œé¢çš„ã€‚ä¸Šé¢è¯´â€œå¯èƒ½â€éœ€è¦
é‡æ–°åšæ˜ å°„ï¼Œå¦‚æœå†…æ ¸åœ¨ highmem æ˜ å°„åŒºç”³è¯·å†…å­˜å¹¶å°†è¿™ä¸ªåœ°å€é€šè¿‡ vmap æ˜ å°„åˆ° 
vmalloc åŒºåŸŸï¼Œåˆ™éœ€è¦ä¿®æ”¹ç›¸åº”é¡µè¡¨é¡¹å¹¶å°†é¡µé¢è®¾ç½®ä¸ºé cache çš„ï¼Œè€Œå¦‚æœå†…æ ¸ä» 
lowmem ç”³è¯·å†…å­˜ï¼Œæˆ‘ä»¬çŸ¥é“è¿™éƒ¨åˆ†æ˜¯å·²ç»çº¿æ€§æ˜ å°„å¥½äº†ï¼Œå› æ­¤ä¸éœ€è¦ä¿®æ”¹é¡µè¡¨ï¼Œåªéœ€ä¿®
æ”¹ç›¸åº”é¡µè¡¨é¡¹ä¸ºé cache å³å¯ã€‚ç›¸å…³çš„æ¥å£å°±æ˜¯ 

{% highlight ruby %}
dma_alloc_coherent()

dma_free_coherent()

dma_cache_sync()
{% endhighlight %}

dma_alloc_coherent() ä¼šä¼ ä¸€ä¸ª device ç»“æ„ä½“æŒ‡æ˜ç»™å“ªä¸ªè®¾å¤‡ç”³è¯·ä¸€è‡´æ€§ DMA å†…å­˜ï¼Œ
å®ƒä¼šäº§ç”Ÿä¸¤ä¸ªåœ°å€ï¼Œä¸€ä¸ªæ˜¯ç»™ CPU çœ‹çš„ï¼Œä¸€ä¸ªæ˜¯ç»™ DMA çœ‹çš„ã€‚CPU éœ€è¦é€šè¿‡è¿”å›çš„è™šæ‹Ÿ
åœ°å€æ¥è®¿é—®è¿™æ®µå†…å­˜ï¼Œæ‰æ˜¯é cache çš„ã€‚è‡³äº dma_alloc_coherent() çš„å†…éƒ¨å®ç°å¯ä»¥
ä¸å…³æ³¨ï¼Œå®ƒæ˜¯å’Œä½“ç³»ç»“æ„å¦‚ä½•å®ç°é cacheï¼ˆå¦‚mipsçš„kseg1ï¼‰ç›¸å…³ï¼Œä¹Ÿå¯èƒ½ä¸ç¡¬ä»¶ç‰¹
æ€§ï¼ˆå¦‚æ˜¯å¦æ”¯æŒ CMAï¼‰ç›¸å…³ã€‚

è¿˜æœ‰ä¸€ä¸ªæ¥å£ dma_cache_sync()ï¼Œå¯ä»¥æ‰‹åŠ¨å»åš cache åŒæ­¥ï¼Œä¸Šé¢è¯´ 
dma_alloc_coherent() åˆ†é…çš„æ˜¯ uncached å†…å­˜ï¼Œä½†æœ‰æ—¶ç»™ DMAç”¨çš„å†…å­˜æ˜¯å…¶ä»–æ¨¡å—å·²
ç»åˆ†é…å¥½çš„ï¼Œä¾‹å¦‚åè®®æ ˆå‘åŒ…æ—¶ï¼Œæœ€ç»ˆè¦æŠŠ skb çš„åœ°å€å’Œé•¿åº¦äº¤ç»™ DMAï¼Œé™¤äº†å°† skb åœ°
å€è½¬æ¢ä¸ºç‰©ç†åœ°å€å¤–ï¼Œè¿˜è¦å°† CPU cache å†™å›ï¼ˆå› ä¸º cache é‡Œå¯èƒ½æ˜¯æ–°çš„ï¼Œå†…å­˜é‡Œæ˜¯æ—§
çš„)ã€‚

è°ƒç”¨è¿™ä¸ªå‡½æ•°çš„æ—¶åˆ»å°±æ˜¯ä¸Šé¢æè¿°çš„æƒ…å†µï¼šå› ä¸ºå†…å­˜æ˜¯å¯ cache çš„ï¼Œå› æ­¤åœ¨ DMA è¯»å†…
å­˜ï¼ˆå†…å­˜åˆ°è®¾å¤‡æ–¹å‘ï¼‰æ—¶ï¼Œç”±äºcache ä¸­å¯èƒ½æœ‰æ–°çš„æ•°æ®ï¼Œå› æ­¤è¦å…ˆå°† cache ä¸­çš„æ•°æ®
å†™å›åˆ°å†…å­˜ï¼›åœ¨ DMA å†™å†…å­˜ï¼ˆè®¾å¤‡åˆ°å†…å­˜æ–¹å‘ï¼‰æ—¶ï¼Œcache ä¸­å¯èƒ½è¿˜æœ‰æ•°æ®æ²¡æœ‰å†™å›ï¼Œ
ä¸ºäº†é˜²æ­¢cache æ•°æ®è¦†ç›– DMA è¦å†™çš„å†…å®¹ï¼Œè¦å…ˆå°† cache æ— æ•ˆã€‚æ³¨æ„è¿™ä¸ªå‡½æ•°çš„ 
vaddr å‚æ•°æ¥æ”¶çš„æ˜¯è™šæ‹Ÿåœ°å€ã€‚ä¾‹å¦‚åœ¨å‘åŒ…æ—¶å°†åè®®æ ˆçš„ skb æ”¾è¿› ring buffer ä¹‹å‰ï¼Œ
è¦åšä¸€æ¬¡ DMA_TO_DEVICE çš„ flushã€‚å¯¹åº”çš„ï¼Œåœ¨æ”¶åŒ…åä¸º ring buffer ä¸­å·²è¢«ä½¿ç”¨çš„ 
skb æ•°æ® buffer é‡æ–°åˆ†é…å†…å­˜åï¼Œè¦åšä¸€æ¬¡ DMA_FROM_DEVICEçš„flushï¼ˆinvalidate
çš„æ—¶å€™è¦æ³¨æ„cache alignï¼‰ã€‚

#### æµå¼DMAæ˜ å°„(DMA Streaming Mapping)

ç›¸å…³æ¥å£ä¸º 

{% highlight ruby %}
dma_map_sg(), dma_unmap_sg()

dma_map_single(),dma_unmap_single()
{% endhighlight %}

ä¸€è‡´æ€§ç¼“å­˜çš„æ–¹å¼æ˜¯å†…æ ¸ä¸“é—¨ç”³è¯·å¥½ä¸€å—å†…å­˜ç»™ DMA ç”¨ã€‚è€Œæœ‰æ—¶é©±åŠ¨å¹¶æ²¡è¿™æ ·åšï¼Œè€Œæ˜¯
è®© DMA å¼•æ“ç›´æ¥åœ¨ä¸Šå±‚ä¼ ä¸‹æ¥çš„å†…å­˜é‡Œåšäº‹æƒ…ã€‚ä¾‹å¦‚ä»åè®®æ ˆé‡Œå‘ä¸‹æ¥çš„ä¸€ä¸ªåŒ…ï¼Œæƒ³é€š
è¿‡ç½‘å¡å‘é€å‡ºå»ã€‚ä½†æ˜¯åè®®æ ˆå¹¶ä¸çŸ¥é“è¿™ä¸ªåŒ…è¦å¾€å“ªé‡Œèµ°ï¼Œå› æ­¤åˆ†é…å†…å­˜çš„æ—¶å€™å¹¶æ²¡æœ‰
ç‰¹æ®Šå¯¹å¾…ï¼Œè¿™ä¸ªåŒ…æ‰€åœ¨çš„å†…å­˜é€šå¸¸éƒ½æ˜¯å¯ä»¥ cache çš„ã€‚è¿™æ—¶ï¼Œå†…å­˜åœ¨ç»™ DMA ä½¿ç”¨ä¹‹å‰ï¼Œ
å°±è¦è°ƒç”¨ä¸€æ¬¡ dma_map_sg() æˆ– dma_map_single()ï¼Œå–å†³äºä½ çš„ DMA å¼•æ“æ˜¯å¦æ”¯æŒèšé›†
æ•£åˆ—ï¼ˆDMA scatter-gatherï¼‰ï¼Œæ”¯æŒå°±ç”¨ dma_map_sg()ï¼Œä¸æ”¯æŒå°±ç”¨ 
dma_map_single()ã€‚DMA ç”¨å®Œä¹‹åè¦è°ƒç”¨å¯¹åº”çš„ unmap æ¥å£ã€‚

ç”±äºåè®®æ ˆä¸‹æ¥çš„åŒ…çš„æ•°æ®æœ‰å¯èƒ½è¿˜åœ¨ cache é‡Œé¢ï¼Œè°ƒç”¨ dma_map_single() åï¼ŒCPU 
å°±ä¼šåšä¸€æ¬¡ cache çš„ flushï¼Œå°† cache çš„æ•°æ®åˆ·åˆ°å†…å­˜ï¼Œè¿™æ · DMA å»è¯»å†…å­˜å°±è¯»åˆ°æ–°
çš„æ•°æ®äº†ã€‚

æ³¨æ„ï¼Œåœ¨ map çš„æ—¶å€™è¦æŒ‡å®šä¸€ä¸ªå‚æ•°ï¼Œæ¥æŒ‡æ˜æ•°æ®çš„æ–¹å‘æ˜¯ä»å¤–è®¾åˆ°å†…å­˜è¿˜æ˜¯ä»å†…å­˜åˆ°
å¤–è®¾ï¼š

> 1. ä»å†…å­˜åˆ°å¤–è®¾ï¼šCPU ä¼šåš cache çš„ flush æ“ä½œï¼Œå°† cache ä¸­æ–°çš„æ•°æ®åˆ·åˆ°å†…å­˜ã€‚
>
> 2. ä»å¤–è®¾åˆ°å†…å­˜ï¼šCPU å°† cache ç½®æ— æ•ˆï¼Œè¿™æ · CPU è¯»çš„æ—¶å€™ä¸å‘½ä¸­ï¼Œå°±ä¼šä»å†…å­˜å»
                   è¯»æ–°çš„æ•°æ®ã€‚

è¿˜è¦æ³¨æ„ï¼Œè¿™å‡ ä¸ªæ¥å£éƒ½æ˜¯ä¸€æ¬¡æ€§çš„ï¼Œæ¯æ¬¡æ“ä½œæ•°æ®éƒ½è¦è°ƒç”¨ä¸€æ¬¡ map å’Œ unmapã€‚å¹¶ä¸”
åœ¨ map æœŸé—´ï¼ŒCPU ä¸èƒ½å»æ“ä½œè¿™æ®µå†…å­˜ï¼Œå› æ­¤å¦‚æœ CPU å»å†™ï¼Œå°±åˆä¸ä¸€è‡´äº†ã€‚åŒæ ·çš„ï¼Œ
dma_map_sg() å’Œ dma_map_single() çš„åç«¯å®ç°ä¹Ÿéƒ½æ˜¯å’Œç¡¬ä»¶ç‰¹æ€§ç›¸å…³ã€‚

#### å…¶ä»–æ–¹å¼

ä¸Šé¢è¯´çš„æ˜¯å¸¸è§„ DMAï¼Œæœ‰äº› SoC å¯ä»¥ç”¨ç¡¬ä»¶åš CPU å’Œå¤–è®¾çš„ cache coherenceï¼Œä¾‹å¦‚åœ¨
SoC ä¸­é›†æˆäº†å«åšâ€œCache Coherent interconnectâ€çš„ç¡¬ä»¶ï¼Œå®ƒå¯ä»¥åšåˆ°è®© DMA è¸åˆ° 
CPU çš„ cache æˆ–è€…å¸®å¿™åš cache çš„åˆ·æ–°ã€‚è¿™æ ·çš„è¯ï¼Œdma_alloc_coherent() ç”³è¯·çš„å†…
å­˜å°±æ²¡å¿…è¦æ˜¯écacheçš„äº†ã€‚

------------------------------------------------------------------

# <span id="Kernel ä¸­ä½¿ç”¨ DMA">Kernel ä¸­ä½¿ç”¨ DMA</span>

é¡¹ç›®å¼€å‘ä¸­éœ€è¦ä½¿ç”¨ DMA è¿›è¡Œå†…å­˜åˆ°å†…å­˜çš„æ‹·è´æˆ–è€…å†…å­˜ä¸å¤–è®¾ä¹‹é—´çš„æ•°æ®æ‹·è´ï¼Œè¿™æ—¶
éœ€è¦ä½¿ç”¨ DMA è¿›è¡Œæ•°æ®çš„æ‹·è´ã€‚ä¸‹é¢æä¾›äº† DMA ä½¿ç”¨çš„é©±åŠ¨ï¼Œå¼€å‘è€…å¯ä»¥æ ¹æ®å®é™…å¼€å‘
éœ€æ±‚è¿›è¡Œä¿®æ”¹.

{% highlight ruby %}
/*
* Copyright (C) 2017 buddy.zhang@aliyun.com
*
* dma device driver demo
*
* This program is free software; you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation; version 2 of the License.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License
* along with this program; if not, write to the Free Software
* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307, USA.
*/
#include <linux/types.h>
#include <linux/string.h>
#include <linux/miscdevice.h>
#include <linux/fs.h>
#include <linux/init.h>
#include <asm/uaccess.h>
#include <linux/dmaengine.h>
#include <linux/kernel.h>
#include <linux/uaccess.h>


#define DRIVER_NAME                     "axidma"
#define AXIDMA_IOC_MAGIC                'A'
#define AXIDMA_IOCGETCHN                _IO(AXIDMA_IOC_MAGIC, 0)
#define AXIDMA_IOCCFGANDSTART           _IO(AXIDMA_IOC_MAGIC, 1)
#define AXIDMA_IOCGETSTATUS             _IO(AXIDMA_IOC_MAGIC, 2)
#define AXIDMA_IOCRELEASECHN            _IO(AXIDMA_IOC_MAGIC, 3)
#define AXI_DMA_MAX_CHANS               8
#define DMA_CHN_UNUSED                  0
#define DMA_CHN_USED                    1
struct axidma_chncfg {
        unsigned int src_addr;
        unsigned int dst_addr;
        unsigned int len;
        unsigned char chn_num;
        unsigned char status;
        unsigned char reserve[2];
        unsigned int reserve2;
};
struct axidma_chns {
        struct dma_chan *dma_chan;
        unsigned char used;
#define DMA_STATUS_UNFINISHED   0
#define DMA_STATUS_FINISHED             1
        unsigned char status;
        unsigned char reserve[2];
};
struct axidma_chns channels[AXI_DMA_MAX_CHANS];
static int axidma_open(struct inode *inode, struct file *file)
{
    printk("Open: do nothing\n");
    return 0;
}
static int axidma_release(struct inode *inode, struct file *file)
{
    printk("Release: do nothing\n");
    return 0;
}
static ssize_t axidma_write(struct file *file, const char __user *data, size_t len, loff_t *ppos)
{
    printk("Write: do nothing\n");
    return 0;
}
static void dma_complete_func(void *status)
{
    *(char *)status = DMA_STATUS_FINISHED;
    printk("dma_complete!\n");
}
static long axidma_unlocked_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
{
    struct dma_device *dma_dev;
    struct dma_async_tx_descriptor *tx = NULL;
    dma_cap_mask_t mask;
    dma_cookie_t cookie;
    enum dma_ctrl_flags flags;
    struct axidma_chncfg chncfg;
    int ret = -1;
    int i;
    memset(&chncfg, 0, sizeof(struct axidma_chncfg));
    switch(cmd) {
    case AXIDMA_IOCGETCHN:
        for(i = 0; i < AXI_DMA_MAX_CHANS; i++) {
            if(DMA_CHN_UNUSED == channels[i].used)
                break;                          
        }
        if (AXI_DMA_MAX_CHANS == i) {
            printk("Get dma chn failed, because no idle channel\n");
            goto error;
        } else {
            channels[i].used   = DMA_CHN_USED;
            channels[i].status = DMA_STATUS_UNFINISHED;
            chncfg.chn_num     = i;
            chncfg.status      = DMA_STATUS_UNFINISHED;
        }
        dma_cap_zero(mask);
        dma_cap_set(DMA_MEMCPY, mask);
        channels[i].dma_chan = dma_request_channel(mask, NULL, NULL);
        if(!channels[i].dma_chan) {
            printk("dma request channel failed\n");
            channels[i].used = DMA_CHN_UNUSED;
            goto error;
        }
        ret = copy_to_user((void __user *)arg, &chncfg,
                                    sizeof(struct axidma_chncfg));
        if(ret) {
            printk("Copy to user failed\n");
            goto error;
        }
        break;
    case AXIDMA_IOCCFGANDSTART:
        ret = copy_from_user(&chncfg, (void __user *)arg,
                       sizeof(struct axidma_chncfg));
        if(ret) {
            printk("Copy from user failed\n");
            goto error;
        }
        if((chncfg.chn_num >= AXI_DMA_MAX_CHANS) ||
                      (!channels[chncfg.chn_num].dma_chan)) {
            printk("chn_num[%d] is invalid\n", chncfg.chn_num);
            goto error;
        }
        dma_dev = channels[chncfg.chn_num].dma_chan->device;
        flags = DMA_CTRL_ACK | DMA_PREP_INTERRUPT;
        tx = dma_dev->device_prep_dma_memcpy(channels[chncfg.chn_num].dma_chan,
                       chncfg.dst_addr, chncfg.src_addr, chncfg.len, flags);
        if(!tx) {
            printk("Failed to prepare DMA memcpy\n");
            goto error;
        }
        tx->callback = dma_complete_func;
        channels[chncfg.chn_num].status = DMA_STATUS_UNFINISHED;
        tx->callback_param = &channels[chncfg.chn_num].status;
        cookie =  tx->tx_submit(tx);
        if(dma_submit_error(cookie)) {
            printk("Failed to dma tx_submit\n");
            goto error;
        }
        dma_async_issue_pending(channels[chncfg.chn_num].dma_chan);
        break;
    case AXIDMA_IOCGETSTATUS:
        ret = copy_from_user(&chncfg, (void __user *)arg,
                             sizeof(struct axidma_chncfg));
        if(ret) {
            printk("Copy from user failed\n");
            goto error;
        }
        if(chncfg.chn_num >= AXI_DMA_MAX_CHANS) {
            printk("chn_num[%d] is invalid\n", chncfg.chn_num);
            goto error;
        }
        chncfg.status = channels[chncfg.chn_num].status;
        ret = copy_to_user((void __user *)arg, &chncfg,
                         sizeof(struct axidma_chncfg));
        if(ret) {
            printk("Copy to user failed\n");
            goto error;
        }
        break;
    case AXIDMA_IOCRELEASECHN:
        ret = copy_from_user(&chncfg, (void __user *)arg,
                  sizeof(struct axidma_chncfg));
        if(ret) {
            printk("Copy from user failed\n");
            goto error;
        }
        if((chncfg.chn_num >= AXI_DMA_MAX_CHANS) ||
                      (!channels[chncfg.chn_num].dma_chan)) {
            printk("chn_num[%d] is invalid\n", chncfg.chn_num);
            goto error;
        }
        dma_release_channel(channels[chncfg.chn_num].dma_chan);
        channels[chncfg.chn_num].used = DMA_CHN_UNUSED;
        channels[chncfg.chn_num].status = DMA_STATUS_UNFINISHED;
        break;
    default:
        printk("Don't support cmd [%d]\n", cmd);
        break;
    }
    return 0;
error:
    return -EFAULT;
}
/*
*    Kernel Interfaces
*/
static struct file_operations axidma_fops = {
    .owner          = THIS_MODULE,
    .llseek         = no_llseek,
    .write          = axidma_write,
    .unlocked_ioctl = axidma_unlocked_ioctl,
    .open           = axidma_open,
    .release        = axidma_release,
};
static struct miscdevice axidma_miscdev = {
    .minor       = MISC_DYNAMIC_MINOR,
    .name        = DRIVER_NAME,
    .fops        = &axidma_fops,
};
static int __init axidma_init(void)
{
    int ret = 0;
    ret = misc_register(&axidma_miscdev);
    if(ret) {
        printk (KERN_ERR "cannot register miscdev (err=%d)\n", ret);
                return ret;
    }
    memset(&channels, 0, sizeof(channels));
    return 0;
}
device_initcall(axidma_init);
{% endhighlight %}

Makefile

{% highlight ruby %}
obj-m += dma.o

KERNELDIR ?= /lib/modules/$(shell uname -r)/build

PWD       := $(shell pwd)

ROOT := $(dir $(M))
DEMOINCLUDE := -I$(ROOT)../include -I$(ROOT)/include

GCCVERSION = $(shell gcc -dumpversion | sed -e 's/\.\([0-9][0-9]\)/\1/g' -e 's/\.\([0-9]\)/0\1/g' -e 's/^[0-9]\{3,4\}$$/&00/')

GCC49 := $(shell expr $(GCCVERSION) \>= 40900)

all:
        $(MAKE) -C $(KERNELDIR) M=$(PWD) modules

install: all
        $(MAKE) -C $(KERNELDIR) M=$(PWD) modules_install
        depmod -a

clean:
        rm -rf *.o *.o.d *~ core .depend .*.cmd *.ko *.ko.unsigned *.mod.c .tmp_versions *.symvers \
        .cache.mk *.save *.bak Modules.* modules.order Module.markers *.bin

CFLAGS_dma.o := -Wall $(DEMOINCLUDE)

ifeq ($(GCC49),1)
        CFLAGS_dma.o += -Wno-error=date-time
endif

CFLAGS_dma.o := $(DEMOINCLUDE)
{% endhighlight %}

å‡†å¤‡å¥½æºç ä¹‹åï¼Œå¼€å‘è€…å¯ä»¥å°†é©±åŠ¨åŠ åˆ°å†…æ ¸æºç æ ‘è¿›è¡Œç¼–è¯‘ï¼Œä¹Ÿå¯ä»¥åœ¨å¤–éƒ¨ç¼–è¯‘ï¼Œå¤–éƒ¨
ç¼–è¯‘ä½¿ç”¨å¦‚ä¸‹å‘½ä»¤ï¼š

{% highlight ruby %}
make
sudo insmod dma.ko
{% endhighlight %}

å½“é©±åŠ¨ç¼–è¯‘åˆ°æºç æˆ–ä¸æ¨¡å—æ–¹å¼åŠ è½½åˆ°å†…æ ¸ä¹‹åï¼Œåœ¨ /dev ç›®å½•ä¸‹å°†ç”Ÿæˆä¸€ä¸ªåä¸º 
axidma çš„è®¾å¤‡èŠ‚ç‚¹ï¼Œè‡³æ­¤ï¼Œé©±åŠ¨åŠ è½½æˆåŠŸã€‚æ¥ä¸‹æ¥è¯·å‚è€ƒç”¨æˆ·ç©ºé—´ DMA ä½¿ç”¨ä¸€èŠ‚å†…å®¹å¯¹
DMA è¿›è¡Œè®¿é—®ã€‚

-------------------------------------------------------------------

# <span id="ç”¨æˆ·ç©ºé—´ä½¿ç”¨ DMA">ç”¨æˆ·ç©ºé—´ä½¿ç”¨ DMA</span>

æœ‰çš„é¡¹ç›®å¼€å‘ä¸­éœ€è¦åœ¨ç”¨æˆ·ç©ºé—´ä½¿ç”¨ DMAï¼Œä¸ºæ­¤å¯ä»¥å‚è€ƒæœ¬èŠ‚è¿›è¡Œç”¨æˆ·ç©ºé—´ DMA çš„ä½¿ç”¨

> github æºç ä½ç½®ï¼š https://github.com/BiscuitOS/HardStack/tree/master/bus/DMA/user

æºç å¦‚ä¸‹ï¼š

{% highlight ruby %}
/*
* DMA application
*
* (C) 2018.11.29 BiscuitOS <buddy.zhang@aliyun.com>
*
* This program is free software; you can redistribute it and/or modify
* it under the terms of the GNU General Public License version 2 as
* published by the Free Software Foundation.
*/
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/ioctl.h>
#include <fcntl.h>
#include <sys/mman.h>

#define DRIVER_NAME             "/dev/axidma"

#define AXIDMA_IOC_MAGIC        'A'
#define AXIDMA_IOCGETCHN        _IO(AXIDMA_IOC_MAGIC, 0)
#define AXIDMA_IOCCFGANDSTART   _IO(AXIDMA_IOC_MAGIC, 1)
#define AXIDMA_IOCGETSTATUS     _IO(AXIDMA_IOC_MAGIC, 2)
#define AXIDMA_IOCRELEASECHN    _IO(AXIDMA_IOC_MAGIC, 3)

#define DMA_STATUS_UNFINISHED   0
#define DMA_STATUS_FINISHED     1

struct axidma_chncfg {
    unsigned int src_addr;
    unsigned int dst_addr;
    unsigned int len;
    unsigned char chn_num;
    unsigned char status;
    unsigned char reserve[2];
    unsigned int reserve2;
};

#define SRC_ADDR         0x60000000
#define DST_ADDR         0x70000000
#define DMA_MEMCPY_LEN     0x300000

int main(void)
{
    struct axidma_chncfg chncfg;
    int fd = -1;
    int ret;
    
    printf("AXI dma test, only support mem to mem: copy %#lx to %#lx,"
                      " size:3M\n", SRC_ADDR, DST_ADDR);
    /* open dev */
    fd = open(DRIVER_NAME, O_RDWR);
    if(fd < 0) {
        printf("open %s failed\n", DRIVER_NAME);
        return -1;
    }
    
    /* get channel */
    ret = ioctl(fd, AXIDMA_IOCGETCHN, &chncfg);
    if(ret){
        printf("ioctl: get channel failed\n");
        goto error;
    }
    printf("channel: %d\n", chncfg.chn_num);
    /* config addr */
    chncfg.src_addr = SRC_ADDR;
    chncfg.dst_addr = DST_ADDR;
    chncfg.len = DMA_MEMCPY_LEN;
    ret = ioctl(fd, AXIDMA_IOCCFGANDSTART, &chncfg);
    if(ret) {
        printf("ioctl: config and start dma failed\n");
        goto error;
    }
    /* wait finish */
    while(1) {
        ret = ioctl(fd, AXIDMA_IOCGETSTATUS, &chncfg);
        if(ret) {
            printf("ioctl: get status failed\n");
            goto error;
        }
        if (DMA_STATUS_FINISHED == chncfg.status) {
            break;
        }
        printf("status:%d\n", chncfg.status);
        sleep(1);
    }
    /* release channel */
    ret = ioctl(fd, AXIDMA_IOCRELEASECHN, &chncfg);
    if(ret) {
        printf("ioctl: release channel failed\n");
        goto error;
    }
    close(fd);
    return 0;
error:
    close(fd);
    return -1;
}
{% endhighlight %}

ç”¨æˆ·ç©ºé—´ä½¿ç”¨ DMA çš„æ ¸å¿ƒæ˜¯ /dev/axidma è®¾å¤‡èŠ‚ç‚¹ï¼Œå¦‚æœä¸å­˜åœ¨è¿™ä¸ªèŠ‚ç‚¹ï¼Œè¯·å‚è€ƒä¸Šä¸€
èŠ‚ kernel ä¸­ä½¿ç”¨ DMA çš„æºç ã€‚é€šè¿‡ä¸Šé¢çš„ä»£ç ï¼Œç”¨æˆ·ç©ºé—´ç¨‹åºå°±å¯ä»¥ä¾¿æ·ä½¿ç”¨ DMAã€‚

<span id="DMA æ€§èƒ½æµ‹è¯•"></span>

ç”¨æˆ·ç©ºé—´ä½¿ç”¨ DMA æ€§èƒ½æµ‹è¯•å¦‚ä¸‹ï¼š

![Menuconfig1](/assets/PDB/BiscuitOS/kernel/DEV000063.png)

CPU æ€§èƒ½å¦‚ä¸‹ï¼š

![Menuconfig1](/assets/PDB/BiscuitOS/kernel/DEV000064.png)

----------------------------------------------------

# <span id="é™„å½•">é™„å½•</span>

> [Linux ä¸‹çš„DMAæµ…æ](https://blog.csdn.net/zqixiao_09/article/details/51089088)
>
> [Linux å†…å­˜ç®¡ç† -- DMA å’Œä¸€è‡´æ€§ç¼“å­˜](https://blog.csdn.net/jasonchen_gbd/article/details/79462064)
>
> [BiscuitOS Home](https://biscuitos.github.io/)
>
> [BiscuitOS Driver](https://biscuitos.github.io/blog/BiscuitOS_Catalogue/)
>
> [BiscuitOS Kernel Build](https://biscuitos.github.io/blog/Kernel_Build/)
>
> [Linux Kernel](https://www.kernel.org/)
>
> [Bootlin: Elixir Cross Referencer](https://elixir.bootlin.com/linux/latest/source)

## èµèµä¸€ä¸‹å§ ğŸ™‚

![MMU](/assets/PDB/BiscuitOS/kernel/HAB000036.jpg)
