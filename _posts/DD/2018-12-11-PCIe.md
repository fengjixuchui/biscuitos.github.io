---
layout: post
title:  "PCIe"
date:   2018-12-11 16:43:33 +0800
categories: [HW]
excerpt: PCIe.
tags:
---

> [GitHub: PCIe](https://github.com/BiscuitOS/HardStack/tree/master/bus/PCIe)
>
> Email: BuddyZhang <buddy.zhang@aliyun.com>

# ç›®å½•

> 1. [PCI æ€»çº¿ç³»ç»Ÿä½“ç³»ç»“æ„](#PCI æ€»çº¿ç³»ç»Ÿä½“ç³»ç»“æ„)
>
> 2. [PCIe è®¾å¤‡é©±åŠ¨å®è·µ](#PCIe è®¾å¤‡é©±åŠ¨å®è·µ)
>
> 3. [PCIé©±åŠ¨ç¨‹åºå®ç°](#PCIé©±åŠ¨ç¨‹åºå®ç°)
>
> 4. [é™„å½•](#é™„å½•)

--------------------------------------------

# <span id="PCI æ€»çº¿ç³»ç»Ÿä½“ç³»ç»“æ„">PCI æ€»çº¿ç³»ç»Ÿä½“ç³»ç»“æ„</span>

{% highlight ruby %}
å†…å®¹æ¥è‡ªç½‘ä¸Šï¼šhttps://blog.csdn.net/wukery/article/details/52869219
{% endhighlight %}

PCI æ˜¯å¤–å›´è®¾å¤‡äº’è¿ï¼ˆPeripheral Component Interconnectï¼‰çš„ç®€ç§°ï¼Œä½œä¸ºä¸€ç§é€šç”¨çš„
æ€»çº¿æ¥å£æ ‡å‡†ï¼Œå®ƒåœ¨ç›®å‰çš„è®¡ç®—æœºç³»ç»Ÿä¸­å¾—åˆ°äº†éå¸¸å¹¿æ³›çš„åº”ç”¨ã€‚PCI æä¾›äº†ä¸€ç»„å®Œæ•´çš„
æ€»çº¿æ¥å£è§„èŒƒï¼Œå…¶ç›®çš„æ˜¯æè¿°å¦‚ä½•å°†è®¡ç®—æœºç³»ç»Ÿä¸­çš„å¤–å›´è®¾å¤‡ä»¥ä¸€ç§ç»“æ„åŒ–å’Œå¯æ§åŒ–çš„æ–¹
å¼è¿æ¥åœ¨ä¸€èµ·ï¼ŒåŒæ—¶å®ƒè¿˜åˆ»ç”»äº†å¤–å›´è®¾å¤‡åœ¨è¿æ¥æ—¶çš„ç”µæ°”ç‰¹æ€§å’Œè¡Œä¸ºè§„çº¦ï¼Œå¹¶ä¸”è¯¦ç»†å®šä¹‰
äº†è®¡ç®—æœºç³»ç»Ÿä¸­çš„å„ä¸ªä¸åŒéƒ¨ä»¶ä¹‹é—´åº”è¯¥å¦‚ä½•æ­£ç¡®åœ°è¿›è¡Œäº¤äº’ã€‚

æ— è®ºæ˜¯åœ¨åŸºäº Intel èŠ¯ç‰‡çš„ PC æœºä¸­ï¼Œæˆ–æ˜¯åœ¨åŸºäº Alpha èŠ¯ç‰‡çš„å·¥ä½œç«™ä¸Šï¼ŒPCI æ¯«æ— ç–‘
é—®éƒ½æ˜¯ç›®å‰ä½¿ç”¨æœ€å¹¿æ³›çš„ä¸€ç§æ€»çº¿æ¥å£æ ‡å‡†ã€‚åŒæ—§å¼çš„ ISA æ€»çº¿ä¸åŒï¼ŒPCI å°†è®¡ç®—æœºç³»
ç»Ÿä¸­çš„æ€»çº¿å­ç³»ç»Ÿä¸å­˜å‚¨å­ç³»ç»Ÿå®Œå…¨åœ°åˆ†å¼€ï¼ŒCPU é€šè¿‡ä¸€å—ç§°ä¸º PCI æ¡¥ï¼ˆPCI-Bridgeï¼‰
çš„è®¾å¤‡æ¥å®ŒæˆåŒæ€»çº¿å­ç³»ç»Ÿçš„äº¤äº’ï¼Œå¦‚å›¾

![VNETCARD](/assets/PDB/BiscuitOS/kernel/DEV000001.png)

ç”±äºä½¿ç”¨äº†æ›´é«˜çš„æ—¶é’Ÿé¢‘ç‡ï¼Œå› æ­¤ PCI æ€»çº¿èƒ½å¤Ÿè·å¾—æ¯” ISA æ€»çº¿æ›´å¥½çš„æ•´ä½“æ€§èƒ½ã€‚PCI 
æ€»çº¿çš„æ—¶é’Ÿé¢‘ç‡ä¸€èˆ¬åœ¨ 25MHz åˆ° 33MHz èŒƒå›´å†…ï¼Œæœ‰äº›ç”šè‡³èƒ½å¤Ÿè¾¾åˆ° 66MHz æˆ–è€… 
133MHzï¼Œè€Œåœ¨ 64 ä½ç³»ç»Ÿä¸­åˆ™æœ€é«˜èƒ½è¾¾åˆ° 266MHzã€‚å°½ç®¡ç›®å‰ PCI è®¾å¤‡å¤§å¤šé‡‡ç”¨ 32 ä½æ•°
æ®æ€»çº¿ï¼Œä½† PCI è§„èŒƒä¸­å·²ç»ç»™å‡ºäº† 64 ä½çš„æ‰©å±•å®ç°ï¼Œä»è€Œä½¿ PCI æ€»çº¿èƒ½å¤Ÿæ›´å¥½åœ°å®ç°
å¹³å°æ— å…³æ€§ï¼Œç°åœ¨ PCI æ€»çº¿å·²ç»èƒ½å¤Ÿç”¨äº IA-32ã€Alphaã€PowerPCã€SPARC64 å’Œ IA-64 
ç­‰ä½“ç³»ç»“æ„ä¸­ã€‚

PCIæ€»çº¿å…·æœ‰ä¸‰ä¸ªéå¸¸æ˜¾è‘—çš„ä¼˜ç‚¹ï¼Œä½¿å¾—å®ƒèƒ½å¤Ÿå®Œæˆæœ€ç»ˆå–ä»£ ISA æ€»çº¿è¿™ä¸€å†å²ä½¿å‘½ï¼š

> 1. åœ¨è®¡ç®—æœºå’Œå¤–è®¾é—´ä¼ è¾“æ•°æ®æ—¶å…·æœ‰æ›´å¥½çš„æ€§èƒ½
>
> 2. èƒ½å¤Ÿå°½é‡ç‹¬ç«‹äºå…·ä½“çš„å¹³å°
>
> 3. å¯ä»¥å¾ˆæ–¹ä¾¿åœ°å®ç°å³æ’å³ç”¨ã€‚


ä¸‹å›¾æ˜¯ä¸€ä¸ªå…¸å‹çš„åŸºäº PCI æ€»çº¿çš„è®¡ç®—æœºç³»ç»Ÿé€»è¾‘ç¤ºæ„å›¾ï¼Œç³»ç»Ÿçš„å„ä¸ªéƒ¨åˆ†é€šè¿‡ PCI æ€»
çº¿å’Œ PCI-PCI æ¡¥è¿æ¥åœ¨ä¸€èµ·ã€‚ä»å›¾ä¸­ä¸éš¾çœ‹å‡ºï¼ŒCPU å’Œ RAM éœ€è¦é€šè¿‡ PCI æ¡¥è¿æ¥åˆ° 
PCI æ€»çº¿ 0ï¼ˆå³ä¸» PCI æ€»çº¿ï¼‰ï¼Œè€Œå…·æœ‰ PCI æ¥å£çš„æ˜¾å¡åˆ™å¯ä»¥ç›´æ¥è¿æ¥åˆ°ä¸» PCI æ€»çº¿
ä¸Šã€‚PCI-PCI æ¡¥æ˜¯ä¸€ä¸ªç‰¹æ®Šçš„ PCI è®¾å¤‡ï¼Œå®ƒè´Ÿè´£å°† PCI æ€»çº¿ 0 å’Œ PCI æ€»çº¿ 1ï¼ˆå³ä» 
PCI ä¸»çº¿ï¼‰è¿æ¥åœ¨ä¸€èµ·ï¼Œé€šå¸¸ PCI æ€»çº¿ 1 ç§°ä¸º PCI-PCI æ¡¥çš„ä¸‹æ¸¸ï¼ˆdownstreamï¼‰ï¼Œè€Œ
PCI æ€»çº¿ 0 åˆ™ç§°ä¸º PCI-PCI æ¡¥çš„ä¸Šæ¸¸ï¼ˆupstreamï¼‰ã€‚å›¾ä¸­è¿æ¥åˆ°ä» PCI æ€»çº¿ä¸Šçš„æ˜¯ 
SCSI å¡å’Œä»¥å¤ªç½‘å¡ã€‚ä¸ºäº†å…¼å®¹æ—§çš„ ISA æ€»çº¿æ ‡å‡†ï¼ŒPCI æ€»çº¿è¿˜å¯ä»¥é€šè¿‡ PCI-ISA æ¡¥æ¥
è¿æ¥ ISA æ€»çº¿ï¼Œä»è€Œèƒ½å¤Ÿæ”¯æŒä»¥å‰çš„ ISA è®¾å¤‡ã€‚å›¾ä¸­ ISA æ€»çº¿ä¸Šè¿æ¥ç€ä¸€ä¸ªå¤šåŠŸèƒ½ 
I/O æ§åˆ¶å™¨ï¼Œç”¨äºæ§åˆ¶é”®ç›˜ã€é¼ æ ‡å’Œè½¯é©±.

![VNETCARD](/assets/PDB/BiscuitOS/kernel/DEV000002.jpg)

åœ¨æ­¤åªå¯¹ PCI æ€»çº¿ç³»ç»Ÿä½“ç³»ç»“æ„ä½œäº†æ¦‚æ‹¬æ€§ä»‹ç»ï¼Œå¦‚æœè¯»è€…æƒ³è¿›ä¸€æ­¥äº†è§£ï¼ŒDavid A 
Rusling åœ¨The Linux  Kernel ï¼ˆhttp://tldp.org/LDP/tlk/dd/pci.htmlï¼‰ä¸­å¯¹ Linux
çš„ PCI å­ç³»ç»Ÿæœ‰æ¯”è¾ƒè¯¦ç»†çš„ä»‹ç»ã€‚

------------------------------------------------------------------

# <span id="PCIe è®¾å¤‡é©±åŠ¨å®è·µ">PCIe è®¾å¤‡é©±åŠ¨å®è·µ</span>

> ç›®æ ‡ä¸»æœºï¼š Intel Ubuntu 14.04 64-Bit
>
> Linux ç‰ˆæœ¬ï¼š 3.19.0-25-generic

PCIe è®¾å¤‡é©±åŠ¨æ¨¡å‹ githubï¼š

{% highlight ruby %}
https://github.com/BiscuitOS/HardStack/tree/master/bus/PCIe/drv
{% endhighlight %}

è·å–æºç æ–¹æ³•ï¼ŒæŒ‰å¦‚ä¸‹å‘½ä»¤

{% highlight ruby %}
cd /tmp/
mkdir PCIe
cd PCIe
git init
git remote add -f  origin https://github.com/BiscuitOS/HardStack.git
git config core.sparsecheckout true
echo "PCIe" >> .git/info/sparse-checkout
git pull origin master
cd bus/PCIe/drv/
{% endhighlight %}

ç¼–è¯‘å¹¶è¿è¡Œé©±åŠ¨ã€‚æŒ‰å¦‚ä¸‹å‘½ä»¤

{% highlight ruby %}
make clean
make
insmod pcie.ko
dmesg
{% endhighlight %}

è¿è¡Œå¦‚ä¸‹å›¾

![VNETCARD](/assets/PDB/BiscuitOS/kernel/DEV000000.png)

#### pcie_demo.c

{% highlight ruby %}
/*
* Copyright (C) 2018 <buddy.zhang@aliyun.com>
*
* PCIe driver demo
*
* This program is free software; you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation; version 2 of the License.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License
* along with this program; if not, write to the Free Software
* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307, USA.
*/
#include <linux/kernel.h>
#include <linux/module.h>
#include <linux/init.h>
#include <linux/fs.h>
#include <linux/miscdevice.h>

#include <linux/pci.h>

#define DEV_NAME                 "pcie_demo"
#define PCIE_DEMO_VENDOR_ID      0x10ee
#define PCIE_DEMO_DEVICE_ID      0x9034
#define BAR_NUM                  6

struct bar_node {
    unsigned long phys;
    unsigned long virt;
    unsigned long length;
    unsigned long used;
};

/* Barn(n=0,1 or 0,1,2,3,4,5) physical address, length, virtual address */
struct bar_node bars[BAR_NUM] = {
    /* Bar0 */
    {
        .phys = 0,
        .virt = 0,
        .length = 0,
        .used = 1,
    },
    /* Bar1 */
    {
        .phys = 0,
        .virt = 0,
        .length = 0,
        .used = 0,
    },
    /* Bar2 */
    {
        .phys = 0,
        .virt = 0,
        .length = 0,
        .used = 1,
    },
    /* Bar3 */
    {
        .phys = 0,
        .virt = 0,
        .length = 0,
        .used = 0,
    },
    /* Bar4 */
    {
        .phys = 0,
        .virt = 0,
        .length = 0,
        .used = 0,
    },
    /* Bar5 */
    {
        .phys = 0,
        .virt = 0,
        .length = 0,
        .used = 0,
    },
};

/*
* open operation
*/
static int pcie_demo_open(struct inode *inode,struct file *filp)
{
    printk(KERN_INFO "Open device\n");
    return 0;
}
/*
* release opertion
*/
static int pcie_demo_release(struct inode *inode,struct file *filp)
{
    return 0;
}
/*
* read operation
*/
static ssize_t pcie_demo_read(struct file *filp,char __user *buffer,size_t count,
                loff_t *offset)
{
    return 0;
}
/*
* write operation
*/
static ssize_t pcie_demo_write(struct file *filp,const char __user *buf,
                size_t count,loff_t *offset)
{
    return 0;
}

static int pcie_demo_probe(struct pci_dev *pdev, const struct pci_device_id *id)
{
    int result;
    int i;

    printk("PCIe probe starting....Vendor %#x DeviceID %#x\n",
                                              id->vendor, id->device);

    /* Enable PCIe */
    if (pci_enable_device(pdev)) {
        result = -EIO;
        goto end;
    }

    pci_set_master(pdev);

    if (unlikely(pci_request_regions(pdev, DEV_NAME))) {
        printk("Failed: pci_request_regions\n");
        result = -EIO;
        goto enable_device_err;
    }

    /* Obtain bar0 to bar5 information */
    for (i = 0; i < BAR_NUM; i++) {
        if (!bars[i].used)
            continue;
        /* Obtain bar physical address */
        bars[i].phys = pci_resource_start(pdev, i);
            if (bars[i].phys < 0) {
                printk("Failed: Bar%d pci_resource_start\n", i);
                result = -EIO;
                goto request_regions_err;
        }

        /* Obtain the length for Bar */
        bars[i].length = pci_resource_len(pdev, 0);
        if (bars[i].length != 0)
            bars[i].virt = (unsigned long)ioremap(bars[i].phys,
                                         bars[i].length);
        

        printk("Bar%d=> phys: %#lx virt: %#lx length: %#lx\n",
                     i, bars[i].phys, bars[i].virt, bars[i].length);
    }

    return 0;

request_regions_err:

    pci_release_regions(pdev);

enable_device_err:
    pci_disable_device(pdev);

end:

    return result;
}

static void pcie_demo_remove(struct pci_dev *pdev)
{
    int i;

    for (i = 0; i < BAR_NUM; i++)
        if (bars[i].virt > 0)
            iounmap((void *)bars[i].virt);

    pci_release_regions(pdev);

    pci_disable_device(pdev);
}

/*
* file_operations
*/
static struct file_operations pcie_demo_fops = {
    .owner     = THIS_MODULE,
    .open      = pcie_demo_open,
    .release   = pcie_demo_release,
    .write     = pcie_demo_write,
    .read      = pcie_demo_read,
};
/*
* misc struct
*/

static struct miscdevice pcie_demo_misc = {
    .minor    = MISC_DYNAMIC_MINOR,
    .name     = DEV_NAME,
    .fops     = &pcie_demo_fops,
};

static struct pci_device_id pcie_demo_ids[] = {
    { PCIE_DEMO_VENDOR_ID, PCIE_DEMO_DEVICE_ID, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
    { 0, }
};
MODULE_DEVICE_TABLE(pci, pcie_demo_ids);

static struct pci_driver pci_drivers = {
    .name = DEV_NAME,
    .id_table = pcie_demo_ids,
    .probe = pcie_demo_probe,
    .remove = pcie_demo_remove,
};


/*
* Init module
*/
static __init int pcie_demo_init(void)
{
    int ret;

    /* Register PCIe driver */
    ret = pci_register_driver(&pci_drivers);

    /* Register Misc layer interface. */
    misc_register(&pcie_demo_misc);

    return 0;
}
/*
* Exit module
*/
static __exit void pcie_demo_exit(void)
{
    /* Unregister PCIe driver */
    pci_unregister_driver(&pci_drivers);

    /* Unregister misc driver */
    misc_deregister(&pcie_demo_misc);
}
/*
* module information
*/
module_init(pcie_demo_init);
module_exit(pcie_demo_exit);

MODULE_LICENSE("GPL");
{% endhighlight %}

#### Makefile

{% highlight ruby %}
obj-m += pcie.o

pcie-objs := pcie_demo.o

KERNELDIR ?= /lib/modules/$(shell uname -r)/build

PWD       := $(shell pwd)

ROOT := $(dir $(M))
DEMOINCLUDE := -I$(ROOT)../include -I$(ROOT)/include

GCCVERSION = $(shell gcc -dumpversion | sed -e 's/\.\([0-9][0-9]\)/\1/g' -e 's/\.\([0-9]\)/0\1/g' -e 's/^[0-9]\{3,4\}$$/&00/')

GCC49 := $(shell expr $(GCCVERSION) \>= 40900)

all:
        $(MAKE) -C $(KERNELDIR) M=$(PWD) modules

install: all
        $(MAKE) -C $(KERNELDIR) M=$(PWD) modules_install
        depmod -a

clean:
        rm -rf *.o *.o.d *~ core .depend .*.cmd *.ko *.ko.unsigned *.mod.c .tmp_versions *.symvers \
                         *.save *.bak Modules.* modules.order Module.markers *.bin

CFLAGS_pcie_demo.o := -Wall $(DEMOINCLUDE)

ifeq ($(GCC49),1)
        CFLAGS_pcie_demo.o += -Wno-error=date-time
endif

CFLAGS_pcie_demo.o := $(DEMOINCLUDE)
{% endhighlight %}

-------------------------------------------------------

# <span id="PCIé©±åŠ¨ç¨‹åºå®ç°">PCIé©±åŠ¨ç¨‹åºå®ç°</span>

### å…³é”®æ•°æ®ç»“æ„

PCI è®¾å¤‡ä¸Šæœ‰ä¸‰ç§åœ°å€ç©ºé—´ï¼šPCI çš„ I/O ç©ºé—´ã€PCI çš„å­˜å‚¨ç©ºé—´å’Œ PCI çš„é…ç½®ç©ºé—´ã€‚
CPU å¯ä»¥è®¿é—® PCI è®¾å¤‡ä¸Šçš„æ‰€æœ‰åœ°å€ç©ºé—´ï¼Œå…¶ä¸­ I/Oç©ºé—´å’Œå­˜å‚¨ç©ºé—´æä¾›ç»™è®¾å¤‡é©±åŠ¨ç¨‹
åºä½¿ç”¨ï¼Œè€Œé…ç½®ç©ºé—´åˆ™ç”± Linux å†…æ ¸ä¸­çš„ PCI åˆå§‹åŒ–ä»£ç ä½¿ç”¨ã€‚å†…æ ¸åœ¨å¯åŠ¨æ—¶è´Ÿè´£å¯¹æ‰€
æœ‰ PCI è®¾å¤‡è¿›è¡Œåˆå§‹åŒ–ï¼Œé…ç½®å¥½æ‰€æœ‰çš„ PCI è®¾å¤‡ï¼ŒåŒ…æ‹¬ä¸­æ–­å·ä»¥åŠ I/O åŸºå€ï¼Œå¹¶åœ¨æ–‡ä»¶
/proc/pci ä¸­åˆ—å‡ºæ‰€æœ‰æ‰¾åˆ°çš„ PCI è®¾å¤‡ï¼Œä»¥åŠè¿™äº›è®¾å¤‡çš„å‚æ•°å’Œå±æ€§ã€‚

Linux é©±åŠ¨ç¨‹åºé€šå¸¸ä½¿ç”¨ç»“æ„ï¼ˆstructï¼‰æ¥è¡¨ç¤ºä¸€ç§è®¾å¤‡ï¼Œè€Œç»“æ„ä½“ä¸­çš„å˜é‡åˆ™ä»£è¡¨æŸä¸€
å…·ä½“è®¾å¤‡ï¼Œè¯¥å˜é‡å­˜æ”¾äº†ä¸è¯¥è®¾å¤‡ç›¸å…³çš„æ‰€æœ‰ä¿¡æ¯ã€‚å¥½çš„é©±åŠ¨ç¨‹åºéƒ½åº”è¯¥èƒ½é©±åŠ¨å¤šä¸ªåŒç§
è®¾å¤‡ï¼Œæ¯ä¸ªè®¾å¤‡ä¹‹é—´ç”¨æ¬¡è®¾å¤‡å·è¿›è¡ŒåŒºåˆ†ï¼Œå¦‚æœé‡‡ç”¨ç»“æ„æ•°æ®æ¥ä»£è¡¨æ‰€æœ‰èƒ½ç”±è¯¥é©±åŠ¨ç¨‹åº
é©±åŠ¨çš„è®¾å¤‡ï¼Œé‚£ä¹ˆå°±å¯ä»¥ç®€å•åœ°ä½¿ç”¨æ•°ç»„ä¸‹æ ‡æ¥è¡¨ç¤ºæ¬¡è®¾å¤‡å·ã€‚åœ¨ PCI é©±åŠ¨ç¨‹åºä¸­ï¼Œä¸‹
é¢å‡ ä¸ªå…³é”®æ•°æ®ç»“æ„èµ·ç€éå¸¸æ ¸å¿ƒçš„ä½œç”¨

##### pci_driver

è¿™ä¸ªæ•°æ®ç»“æ„åœ¨æ–‡ä»¶ include/linux/pci.h é‡Œï¼Œè¿™æ˜¯ Linux å†…æ ¸ç‰ˆæœ¬ 2.4 ä¹‹åä¸ºæ–°å‹çš„
PCI è®¾å¤‡é©±åŠ¨ç¨‹åºæ‰€æ·»åŠ çš„ï¼Œå…¶ä¸­æœ€ä¸»è¦çš„æ˜¯ç”¨äºè¯†åˆ«è®¾å¤‡çš„ id_table ç»“æ„ï¼Œä»¥åŠç”¨äº
æ£€æµ‹è®¾å¤‡çš„å‡½æ•° probe( ) å’Œå¸è½½è®¾å¤‡çš„å‡½æ•° remove( )ï¼š

{% highlight ruby %}
    struct pci_driver {
        struct list_head node;
        char *name;
        const struct pci_device_id *id_table;
        int  (*probe)  (struct pci_dev *dev, const struct pci_device_id *id);
        void (*remove) (struct pci_dev *dev);
        int  (*save_state) (struct pci_dev *dev, u32 state);
        int  (*suspend)(struct pci_dev *dev, u32 state);
        int  (*resume) (struct pci_dev *dev);
        int  (*enable_wake) (struct pci_dev *dev, u32 state, int enable);
    };
{% endhighlight %}

##### pci_dev

è¿™ä¸ªæ•°æ®ç»“æ„ä¹Ÿåœ¨æ–‡ä»¶ include/linux/pci.h é‡Œï¼Œå®ƒè¯¦ç»†æè¿°äº†ä¸€ä¸ª PCI è®¾å¤‡å‡ ä¹æ‰€æœ‰
çš„ç¡¬ä»¶ä¿¡æ¯ï¼ŒåŒ…æ‹¬å‚å•† IDã€è®¾å¤‡ IDã€å„ç§èµ„æºç­‰ï¼š

{% highlight ruby %}
    struct pci_dev {
        struct list_head global_list;
        struct list_head bus_list;
        struct pci_bus  *bus;
        struct pci_bus  *subordinate;
        void        *sysdata;
        struct proc_dir_entry *procent;
        unsigned int    devfn;
        unsigned short  vendor;
        unsigned short  device;
        unsigned short  subsystem_vendor;
        unsigned short  subsystem_device;
        unsigned int    class;
        u8      hdr_type;
        u8      rom_base_reg;
        struct pci_driver *driver;
        void        *driver_data;
        u64     dma_mask;
        u32             current_state;
        unsigned short vendor_compatible[DEVICE_COUNT_COMPATIBLE];
        unsigned short device_compatible[DEVICE_COUNT_COMPATIBLE];
        unsigned int    irq;
        struct resource resource[DEVICE_COUNT_RESOURCE];
        struct resource dma_resource[DEVICE_COUNT_DMA];
        struct resource irq_resource[DEVICE_COUNT_IRQ];
        char        name[80];
        char        slot_name[8];
        int     active;
        int     ro;
        unsigned short  regs;
        int (*prepare)(struct pci_dev *dev);
        int (*activate)(struct pci_dev *dev);
        int (*deactivate)(struct pci_dev *dev);
    };
{% endhighlight %}

### åŸºæœ¬æ¡†æ¶

åœ¨ç”¨æ¨¡å—æ–¹å¼å®ç° PCI è®¾å¤‡é©±åŠ¨ç¨‹åºæ—¶ï¼Œé€šå¸¸è‡³å°‘è¦å®ç°ä»¥ä¸‹å‡ ä¸ªéƒ¨åˆ†ï¼šåˆå§‹åŒ–è®¾å¤‡æ¨¡
å—ã€è®¾å¤‡æ‰“å¼€æ¨¡å—ã€æ•°æ®è¯»å†™å’Œæ§åˆ¶æ¨¡å—ã€ä¸­æ–­å¤„ç†æ¨¡å—ã€è®¾å¤‡é‡Šæ”¾æ¨¡å—ã€è®¾å¤‡å¸è½½æ¨¡
å—ã€‚ä¸‹é¢ç»™å‡ºä¸€ä¸ªå…¸å‹çš„PCIè®¾å¤‡é©±åŠ¨ç¨‹åºçš„åŸºæœ¬æ¡†æ¶ï¼Œä»ä¸­ä¸éš¾ä½“ä¼šåˆ°è¿™å‡ ä¸ªå…³é”®æ¨¡å—
æ˜¯å¦‚ä½•ç»„ç»‡èµ·æ¥çš„ã€‚

{% highlight ruby %}
/* æŒ‡æ˜è¯¥é©±åŠ¨ç¨‹åºé€‚ç”¨äºå“ªä¸€äº›PCIè®¾å¤‡ */
static struct pci_device_id demo_pci_tbl [] __initdata = {
    {PCI_VENDOR_ID_DEMO, PCI_DEVICE_ID_DEMO,
     PCI_ANY_ID, PCI_ANY_ID, 0, 0, DEMO},
    {0,}
};
/* å¯¹ç‰¹å®šPCIè®¾å¤‡è¿›è¡Œæè¿°çš„æ•°æ®ç»“æ„ */
struct demo_card {
    unsigned int magic;
    /* ä½¿ç”¨é“¾è¡¨ä¿å­˜æ‰€æœ‰åŒç±»çš„PCIè®¾å¤‡ */
    struct demo_card *next;
     
    /* ... */
}
/* ä¸­æ–­å¤„ç†æ¨¡å— */
static void demo_interrupt(int irq, void *dev_id, struct pt_regs *regs)
{
    /* ... */
}
/* è®¾å¤‡æ–‡ä»¶æ“ä½œæ¥å£ */
static struct file_operations demo_fops = {
    owner:      THIS_MODULE,   /* demo_fopsæ‰€å±çš„è®¾å¤‡æ¨¡å— */
    read:       demo_read,    /* è¯»è®¾å¤‡æ“ä½œ*/
    write:      demo_write,    /* å†™è®¾å¤‡æ“ä½œ*/
    ioctl:      demo_ioctl,    /* æ§åˆ¶è®¾å¤‡æ“ä½œ*/
    mmap:       demo_mmap,    /* å†…å­˜é‡æ˜ å°„æ“ä½œ*/
    open:       demo_open,    /* æ‰“å¼€è®¾å¤‡æ“ä½œ*/
    release:    demo_release    /* é‡Šæ”¾è®¾å¤‡æ“ä½œ*/
    /* ... */
};
/* è®¾å¤‡æ¨¡å—ä¿¡æ¯ */
static struct pci_driver demo_pci_driver = {
    name:       demo_MODULE_NAME,    /* è®¾å¤‡æ¨¡å—åç§° */
    id_table:   demo_pci_tbl,    /* èƒ½å¤Ÿé©±åŠ¨çš„è®¾å¤‡åˆ—è¡¨ */
    probe:      demo_probe,    /* æŸ¥æ‰¾å¹¶åˆå§‹åŒ–è®¾å¤‡ */
    remove:     demo_remove    /* å¸è½½è®¾å¤‡æ¨¡å— */
};
static int __init demo_init_module (void)
{
}
static void __exit demo_cleanup_module (void)
{
    pci_unregister_driver(&demo_pci_driver);
}
module_init(demo_init_module);
module_exit(demo_cleanup_module);
{% endhighlight %}


ä¸Šé¢è¿™æ®µä»£ç ç»™å‡ºäº†ä¸€ä¸ªå…¸å‹çš„ PCI è®¾å¤‡é©±åŠ¨ç¨‹åºçš„æ¡†æ¶ï¼Œæ˜¯ä¸€ç§ç›¸å¯¹å›ºå®šçš„æ¨¡å¼ã€‚éœ€
è¦æ³¨æ„çš„æ˜¯ï¼ŒåŒåŠ è½½å’Œå¸è½½æ¨¡å—ç›¸å…³çš„å‡½æ•°æˆ–æ•°æ®ç»“æ„éƒ½è¦åœ¨å‰é¢åŠ ä¸Š __initã€__exit 
ç­‰æ ‡å¿—ç¬¦ï¼Œä»¥ä½¿åŒæ™®é€šå‡½æ•°åŒºåˆ†å¼€æ¥ã€‚æ„é€ å‡ºè¿™æ ·ä¸€ä¸ªæ¡†æ¶ä¹‹åï¼Œæ¥ä¸‹å»çš„å·¥ä½œå°±æ˜¯å¦‚ä½•
å®Œæˆæ¡†æ¶å†…çš„å„ä¸ªåŠŸèƒ½æ¨¡å—äº†ã€‚

### åˆå§‹åŒ–è®¾å¤‡æ¨¡å—

åœ¨Linuxç³»ç»Ÿä¸‹ï¼Œæƒ³è¦å®Œæˆå¯¹ä¸€ä¸ªPCIè®¾å¤‡çš„åˆå§‹åŒ–ï¼Œéœ€è¦å®Œæˆä»¥ä¸‹å·¥ä½œï¼š

> 1. æ£€æŸ¥PCIæ€»çº¿æ˜¯å¦è¢«Linuxå†…æ ¸æ”¯æŒï¼›
>
> 2. æ£€æŸ¥è®¾å¤‡æ˜¯å¦æ’åœ¨æ€»çº¿æ’æ§½ä¸Šï¼Œå¦‚æœåœ¨çš„è¯åˆ™ä¿å­˜å®ƒæ‰€å ç”¨çš„æ’æ§½çš„ä½ç½®ç­‰ä¿¡æ¯ã€‚
>
> 3. è¯»å‡ºé…ç½®å¤´ä¸­çš„ä¿¡æ¯æä¾›ç»™é©±åŠ¨ç¨‹åºä½¿ç”¨ã€‚


å½“ Linux å†…æ ¸å¯åŠ¨å¹¶å®Œæˆå¯¹æ‰€æœ‰ PCI è®¾å¤‡è¿›è¡Œæ‰«æã€ç™»å½•å’Œåˆ†é…èµ„æºç­‰åˆå§‹åŒ–æ“ä½œçš„åŒ
æ—¶ï¼Œä¼šå»ºç«‹èµ·ç³»ç»Ÿä¸­æ‰€æœ‰ PCI è®¾å¤‡çš„æ‹“æ‰‘ç»“æ„ï¼Œæ­¤åå½“ PCI é©±åŠ¨ç¨‹åºéœ€è¦å¯¹è®¾å¤‡è¿›è¡Œåˆ
å§‹åŒ–æ—¶ï¼Œä¸€èˆ¬éƒ½ä¼šè°ƒç”¨å¦‚ä¸‹çš„ä»£ç ï¼š

{% highlight ruby %}
static int __init demo_init_module (void)
{
    /* æ£€æŸ¥ç³»ç»Ÿæ˜¯å¦æ”¯æŒPCIæ€»çº¿ */
    if (!pci_present())
        return -ENODEV;
    /* æ³¨å†Œç¡¬ä»¶é©±åŠ¨ç¨‹åº */
    if (!pci_register_driver(&demo_pci_driver)) {
        pci_unregister_driver(&demo_pci_driver);
                return -ENODEV;
    }
    /* ... */
    
    return 0;
}
{% endhighlight %}

é©±åŠ¨ç¨‹åºé¦–å…ˆè°ƒç”¨å‡½æ•° pci_present( ) æ£€æŸ¥ PCI æ€»çº¿æ˜¯å¦å·²ç»è¢« Linux å†…æ ¸æ”¯æŒï¼Œå¦‚
æœç³»ç»Ÿæ”¯æŒ PCI æ€»çº¿ç»“æ„ï¼Œè¿™ä¸ªå‡½æ•°çš„è¿”å›å€¼ä¸º 0ï¼Œå¦‚æœé©±åŠ¨ç¨‹åºåœ¨è°ƒç”¨è¿™ä¸ªå‡½æ•°æ—¶å¾—
åˆ°äº†ä¸€ä¸ªé 0 çš„è¿”å›å€¼ï¼Œé‚£ä¹ˆé©±åŠ¨ç¨‹åºå°±å¿…é¡»å¾—ä¸­æ­¢è‡ªå·±çš„ä»»åŠ¡äº†ã€‚åœ¨ 2.4 ä»¥å‰çš„å†…æ ¸
ä¸­ï¼Œéœ€è¦æ‰‹å·¥è°ƒç”¨ pci_find_device( ) å‡½æ•°æ¥æŸ¥æ‰¾ PCI è®¾å¤‡ï¼Œä½†åœ¨ 2.4 ä»¥åæ›´å¥½çš„åŠ
æ³•æ˜¯è°ƒç”¨ pci_register_driver( ) å‡½æ•°æ¥æ³¨å†Œ PCI è®¾å¤‡çš„é©±åŠ¨ç¨‹åºï¼Œæ­¤æ—¶éœ€è¦æä¾›ä¸€ä¸ª
pci_driver ç»“æ„ï¼Œåœ¨è¯¥ç»“æ„ä¸­ç»™å‡ºçš„ probe æ¢æµ‹ä¾‹ç¨‹å°†è´Ÿè´£å®Œæˆå¯¹ç¡¬ä»¶çš„æ£€æµ‹å·¥ä½œã€‚

{% highlight ruby %}
static int __init demo_probe(struct pci_dev *pci_dev, const struct pci_device_id *pci_id)
{
    struct demo_card *card;
    /* å¯åŠ¨PCIè®¾å¤‡ */
    if (pci_enable_device(pci_dev))
        return -EIO;
    /* è®¾å¤‡DMAæ ‡è¯† */
    if (pci_set_dma_mask(pci_dev, DEMO_DMA_MASK)) {
        return -ENODEV;
    }
    /* åœ¨å†…æ ¸ç©ºé—´ä¸­åŠ¨æ€ç”³è¯·å†…å­˜ */
    if ((card = kmalloc(sizeof(struct demo_card), GFP_KERNEL)) == NULL) {
        printk(KERN_ERR "pci_demo: out of memory\n");
        return -ENOMEM;
    }
    memset(card, 0, sizeof(*card));
    /* è¯»å–PCIé…ç½®ä¿¡æ¯ */
    card->iobase = pci_resource_start (pci_dev, 1);
    card->pci_dev = pci_dev;
    card->pci_id = pci_id->device;
    card->irq = pci_dev->irq;
    card->next = devs;
    card->magic = DEMO_CARD_MAGIC;
    /* è®¾ç½®æˆæ€»çº¿ä¸»DMAæ¨¡å¼ */    
    pci_set_master(pci_dev);
    /* ç”³è¯·I/Oèµ„æº */
    request_region(card->iobase, 64, card_names[pci_id->driver_data]);
    return 0;
}
{% endhighlight %}

### æ‰“å¼€è®¾å¤‡æ¨¡å—

åœ¨è¿™ä¸ªæ¨¡å—é‡Œä¸»è¦å®ç°ç”³è¯·ä¸­æ–­ã€æ£€æŸ¥è¯»å†™æ¨¡å¼ä»¥åŠç”³è¯·å¯¹è®¾å¤‡çš„æ§åˆ¶æƒç­‰ã€‚åœ¨ç”³è¯·æ§åˆ¶
æƒçš„æ—¶å€™ï¼Œéé˜»å¡æ–¹å¼é‡å¿™è¿”å›ï¼Œå¦åˆ™è¿›ç¨‹ä¸»åŠ¨æ¥å—è°ƒåº¦ï¼Œè¿›å…¥ç¡çœ çŠ¶æ€ï¼Œç­‰å¾…å…¶å®ƒè¿›ç¨‹
é‡Šæ”¾å¯¹è®¾å¤‡çš„æ§åˆ¶æƒã€‚

{% highlight ruby %}
static int demo_open(struct inode *inode, struct file *file)
{
    /* ç”³è¯·ä¸­æ–­ï¼Œæ³¨å†Œä¸­æ–­å¤„ç†ç¨‹åº */
    request_irq(card->irq, &demo_interrupt, SA_SHIRQ,
        card_names[pci_id->driver_data], card)) {
    /* æ£€æŸ¥è¯»å†™æ¨¡å¼ */
    if(file->f_mode & FMODE_READ) {
        /* ... */
    }
    if(file->f_mode & FMODE_WRITE) {
       /* ... */
    }
     
    /* ç”³è¯·å¯¹è®¾å¤‡çš„æ§åˆ¶æƒ */
    down(&card->open_sem);
    while(card->open_mode & file->f_mode) {
        if (file->f_flags & O_NONBLOCK) {
            /* NONBLOCKæ¨¡å¼ï¼Œè¿”å›-EBUSY */
            up(&card->open_sem);
            return -EBUSY;
        } else {
            /* ç­‰å¾…è°ƒåº¦ï¼Œè·å¾—æ§åˆ¶æƒ */
            card->open_mode |= f_mode & (FMODE_READ | FMODE_WRITE);
            up(&card->open_sem);
            /* è®¾å¤‡æ‰“å¼€è®¡æ•°å¢1 */
            MOD_INC_USE_COUNT;
            /* ... */
        }
    }
}
{% endhighlight %}

### æ•°æ®è¯»å†™å’Œæ§åˆ¶ä¿¡æ¯æ¨¡å—

PCI è®¾å¤‡é©±åŠ¨ç¨‹åºå¯ä»¥é€šè¿‡ demo_fops ç»“æ„ä¸­çš„å‡½æ•° demo_ioctl( )ï¼Œå‘åº”ç”¨ç¨‹åºæä¾›
å¯¹ç¡¬ä»¶è¿›è¡Œæ§åˆ¶çš„æ¥å£ã€‚ä¾‹å¦‚ï¼Œé€šè¿‡å®ƒå¯ä»¥ä» I/Oå¯„å­˜å™¨é‡Œè¯»å–ä¸€ä¸ªæ•°æ®ï¼Œå¹¶ä¼ é€åˆ°ç”¨æˆ·
ç©ºé—´é‡Œï¼š

{% highlight ruby %}
static int demo_ioctl(struct inode *inode, struct file *file,
      unsigned int cmd, unsigned long arg)
{
    switch(cmd) {
        case DEMO_RDATA:
            /* ä»I/Oç«¯å£è¯»å–4å­—èŠ‚çš„æ•°æ® */
            val = inl(card->iobae + 0x10);
             
            return 0;
    }
}
{% endhighlight %}

äº‹å®ä¸Šï¼Œåœ¨ demo_fops é‡Œè¿˜å¯ä»¥å®ç°è¯¸å¦‚ demo_read( )ã€demo_mmap( ) ç­‰æ“ä½œï¼ŒLinux
å†…æ ¸æºç ä¸­çš„ driver ç›®å½•é‡Œæä¾›äº†è®¸å¤šè®¾å¤‡é©±åŠ¨ç¨‹åºçš„æºä»£ç ï¼Œæ‰¾é‚£é‡Œå¯ä»¥æ‰¾åˆ°ç±»ä¼¼çš„
ä¾‹å­ã€‚åœ¨å¯¹èµ„æºçš„è®¿é—®æ–¹å¼ä¸Šï¼Œé™¤äº†æœ‰ I/O æŒ‡ä»¤ä»¥å¤–ï¼Œè¿˜æœ‰å¯¹å¤–è®¾ I/O å†…å­˜çš„è®¿é—®ã€‚å¯¹
è¿™äº›å†…å­˜çš„æ“ä½œä¸€æ–¹é¢å¯ä»¥é€šè¿‡æŠŠ I/O å†…å­˜é‡æ–°æ˜ å°„åä½œä¸ºæ™®é€šå†…å­˜è¿›è¡Œæ“ä½œï¼Œå¦ä¸€æ–¹
é¢ä¹Ÿå¯ä»¥é€šè¿‡æ€»çº¿ä¸» DMAï¼ˆBus Master DMAï¼‰çš„æ–¹å¼è®©è®¾å¤‡æŠŠæ•°æ®é€šè¿‡ DMA ä¼ é€åˆ°ç³»ç»Ÿ
å†…å­˜ä¸­ã€‚

### ä¸­æ–­å¤„ç†æ¨¡å—

PC çš„ä¸­æ–­èµ„æºæ¯”è¾ƒæœ‰é™ï¼Œåªæœ‰ 0~15 çš„ä¸­æ–­å·ï¼Œå› æ­¤å¤§éƒ¨åˆ†å¤–éƒ¨è®¾å¤‡éƒ½æ˜¯ä»¥å…±äº«çš„å½¢å¼
ç”³è¯·ä¸­æ–­å·çš„ã€‚å½“ä¸­æ–­å‘ç”Ÿçš„æ—¶å€™ï¼Œä¸­æ–­å¤„ç†ç¨‹åºé¦–å…ˆè´Ÿè´£å¯¹ä¸­æ–­è¿›è¡Œè¯†åˆ«ï¼Œç„¶åå†åšè¿›
ä¸€æ­¥çš„å¤„ç†ã€‚

{% highlight ruby %}
static void demo_interrupt(int irq, void *dev_id, struct pt_regs *regs)
{
    struct demo_card *card = (struct demo_card *)dev_id;
    u32 status;
    spin_lock(&card->lock);
    /* è¯†åˆ«ä¸­æ–­ */
    status = inl(card->iobase + GLOB_STA);
    if(!(status & INT_MASK))
    {
        spin_unlock(&card->lock);
        return;  /* not for us */
    }
    /* å‘Šè¯‰è®¾å¤‡å·²ç»æ”¶åˆ°ä¸­æ–­ */
    outl(status & INT_MASK, card->iobase + GLOB_STA);
    spin_unlock(&card->lock);
     
    /* å…¶å®ƒè¿›ä¸€æ­¥çš„å¤„ç†ï¼Œå¦‚æ›´æ–°DMAç¼“å†²åŒºæŒ‡é’ˆç­‰ */
}
{% endhighlight %}

### é‡Šæ”¾è®¾å¤‡æ¨¡å—

é‡Šæ”¾è®¾å¤‡æ¨¡å—ä¸»è¦è´Ÿè´£é‡Šæ”¾å¯¹è®¾å¤‡çš„æ§åˆ¶æƒï¼Œé‡Šæ”¾å ç”¨çš„å†…å­˜å’Œä¸­æ–­ç­‰ï¼Œæ‰€åšçš„äº‹æƒ…æ­£å¥½
ä¸æ‰“å¼€è®¾å¤‡æ¨¡å—ç›¸åï¼š

{% highlight ruby %}    
static int demo_release(struct inode *inode, struct file *file)
{
    /* ... */
     
    /* é‡Šæ”¾å¯¹è®¾å¤‡çš„æ§åˆ¶æƒ */
    card->open_mode &= (FMODE_READ | FMODE_WRITE);
     
    /* å”¤é†’å…¶å®ƒç­‰å¾…è·å–æ§åˆ¶æƒçš„è¿›ç¨‹ */
    wake_up(&card->open_wait);
    up(&card->open_sem);
     
    /* é‡Šæ”¾ä¸­æ–­ */
    free_irq(card->irq, card);
     
    /* è®¾å¤‡æ‰“å¼€è®¡æ•°å¢1 */
    MOD_DEC_USE_COUNT;
     
    /* ... */  
}
{% endhighlight %}

### å¸è½½è®¾å¤‡æ¨¡å—

å¸è½½è®¾å¤‡æ¨¡å—ä¸åˆå§‹åŒ–è®¾å¤‡æ¨¡å—æ˜¯ç›¸å¯¹åº”çš„ï¼Œå®ç°èµ·æ¥ç›¸å¯¹æ¯”è¾ƒç®€å•ï¼Œä¸»è¦æ˜¯è°ƒç”¨å‡½æ•° 
pci_unregister_driver( ) ä» Linux å†…æ ¸ä¸­æ³¨é”€è®¾å¤‡é©±åŠ¨ç¨‹åºï¼š

{% highlight ruby %}
static void __exit demo_cleanup_module (void)
{
    pci_unregister_driver(&demo_pci_driver);
}
{% endhighlight %}

-----------------------------------------

# <span id="é™„å½•">é™„å½•</span>

> [Linuxä¸‹PCIè®¾å¤‡é©±åŠ¨ç¨‹åºå¼€å‘](https://www.ibm.com/developerworks/cn/linux/l-pci/)
>
> [David A Ruslingåœ¨ The Linux Kernelä¸­å¯¹Linuxçš„PCIå­ç³»ç»Ÿè¿›è¡Œäº†æ¯”è¾ƒè¯¦ç»†çš„ä»‹ç»](http://tldp.org/LDP/tlk/dd/pci.html)
>
> [BiscuitOS Home](https://biscuitos.github.io/)
>
> [BiscuitOS Driver](/blog/BiscuitOS_Catalogue/)
>
> [BiscuitOS Kernel Build](/blog/Kernel_Build/)
>
> [Linux Kernel](https://www.kernel.org/)
>
> [Bootlin: Elixir Cross Referencer](https://elixir.bootlin.com/linux/latest/source)

## èµèµä¸€ä¸‹å§ ğŸ™‚

![MMU](/assets/PDB/BiscuitOS/kernel/HAB000036.jpg)
