---
layout: post
title:  "SPI"
date:   2018-12-20 17:27:30 +0800
categories: [HW]
excerpt: SPI.
tags:
  - Bus
---

> [GitHub: SPI](https://github.com/BiscuitOS/HardStack/tree/master/bus/spi)
>
> Email: BuddyZhang1 <buddy.zhang@aliyun.com>

# ç›®å½•

> 1. [SPI åŸç†](#SPI åŸç†)
>
> 2. [Uboot ä¸­æºç æˆ–å·¥å…·è®¿é—® SPI](#Uboot ä¸­æºç æˆ–å·¥å…·è®¿é—® SPI)
>
> 3. [Kernel ä¸­æºç è®¿é—® SPI](#Kernel ä¸­æºç è®¿é—® SPI)
>
> 4. [ç”¨æˆ·ç©ºé—´ä¸­æºç æˆ–å·¥å…·è®¿é—® SPI](#ç”¨æˆ·ç©ºé—´ä¸­æºç æˆ–å·¥å…·è®¿é—® SPI)
>
> 5. [SPI ç¡¬ä»¶ä¿¡å·æµ‹è¯•](#SPI ç¡¬ä»¶ä¿¡å·æµ‹è¯•)
> 
> 6. [é™„å½•](#é™„å½•)

-----------------------------------------------------

# <span id="SPI åŸç†">SPI åŸç†</span>

SPI æ˜¯è‹±è¯­ Serial Peripheral interface çš„ç¼©å†™ï¼Œé¡¾åæ€ä¹‰å°±æ˜¯ä¸²è¡Œå¤–å›´è®¾å¤‡æ¥å£ï¼Œ
æ˜¯ Motorola é¦–å…ˆåœ¨å…¶ MC68HCXX ç³»åˆ—å¤„ç†å™¨ä¸Šå®šä¹‰çš„ã€‚SPI æ¥å£ä¸»è¦åº”ç”¨åœ¨ EEPROMï¼Œ
FLASHï¼Œå®æ—¶æ—¶é’Ÿï¼ŒADè½¬æ¢å™¨ï¼Œè¿˜æœ‰æ•°å­—ä¿¡å·å¤„ç†å™¨å’Œæ•°å­—ä¿¡å·è§£ç å™¨ä¹‹é—´ã€‚SPI æ˜¯ä¸€ç§
é«˜é€Ÿçš„ï¼Œå…¨åŒå·¥ï¼ŒåŒæ­¥çš„é€šä¿¡æ€»çº¿ï¼Œå¹¶ä¸”åœ¨èŠ¯ç‰‡çš„ç®¡è„šä¸Šåªå ç”¨å››æ ¹çº¿ï¼ŒèŠ‚çº¦äº†èŠ¯ç‰‡çš„ç®¡
è„šï¼ŒåŒæ—¶ä¸º PCB çš„å¸ƒå±€ä¸ŠèŠ‚çœç©ºé—´ï¼Œæä¾›æ–¹ä¾¿ã€‚

{% highlight ruby %}
+------------------------+                    +------------------------+
|                  SCLK -|------------------->|  SCLK                  |
|  SPI             MOSI -|------------------->|  MOSI             SPI  |
| Master           MISO  |<-------------------|- MISO            Slave |
|                  CS^  -|------------------->|  CS^                   |
+------------------------+                    +------------------------+
{% endhighlight %}

SPI çš„é€šä¿¡åŸç†å¾ˆç®€å•ï¼Œå®ƒä»¥ä¸»ä»æ–¹å¼å·¥ä½œï¼Œè¿™ç§æ¨¡å¼é€šå¸¸æœ‰ä¸€ä¸ªä¸»è®¾å¤‡å’Œä¸€ä¸ªæˆ–å¤šä¸ªä»
è®¾å¤‡ï¼Œéœ€è¦ 4 æ ¹çº¿ï¼Œäº‹å®ä¸Š 3 æ ¹ä¹Ÿå¯ä»¥ã€‚ä¹Ÿæ˜¯æ‰€æœ‰åŸºäº SPI çš„è®¾å¤‡å…±æœ‰çš„ï¼Œå®ƒä»¬æ˜¯ 
SDI (æ•°æ®è¾“å…¥)ï¼ŒSDO (æ•°æ®è¾“å‡º)ï¼ŒSCLK (æ—¶é’Ÿ)ï¼ŒCS (ç‰‡é€‰)

> 1. MOSI(SDO)ï¼šä¸»å™¨ä»¶æ•°æ®è¾“å‡ºï¼Œä»å™¨ä»¶æ•°æ®è¾“å…¥ã€‚
>
> 2. MISO(SDI)ï¼šä¸»å™¨ä»¶æ•°æ®è¾“å…¥ï¼Œä»å™¨ä»¶æ•°æ®è¾“å‡ºã€‚
>
> 3. SCLK ï¼šæ—¶é’Ÿä¿¡å·ï¼Œç”±ä¸»å™¨ä»¶äº§ç”Ÿã€‚
>
> 4. CSï¼šä»å™¨ä»¶ä½¿èƒ½ä¿¡å·ï¼Œç”±ä¸»å™¨ä»¶æ§åˆ¶ã€‚

å…¶ä¸­ CS æ˜¯æ§åˆ¶èŠ¯ç‰‡æ˜¯å¦è¢«é€‰ä¸­çš„ï¼Œä¹Ÿå°±æ˜¯è¯´åªæœ‰ç‰‡é€‰ä¿¡å·ä¸ºé¢„å…ˆè§„å®šçš„ä½¿èƒ½ä¿¡å·æ—¶ï¼ˆé«˜
ç”µä½æˆ–ä½ç”µä½ï¼‰ï¼Œå¯¹æ­¤èŠ¯ç‰‡çš„æ“ä½œæ‰æœ‰æ•ˆï¼Œè¿™å°±å…è®¸åœ¨åŒä¸€æ€»çº¿ä¸Šè¿æ¥å¤šä¸ª SPI è®¾å¤‡æˆ
ä¸ºå¯èƒ½ã€‚éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œåœ¨å…·ä½“çš„åº”ç”¨ä¸­ï¼Œå½“ä¸€æ¡ SPI æ€»çº¿ä¸Šè¿æ¥æœ‰å¤šä¸ªè®¾å¤‡æ—¶ï¼ŒSPI 
æœ¬èº«çš„ CS æœ‰å¯èƒ½è¢«å…¶ä»–çš„ GPIO è„šä»£æ›¿ï¼Œå³æ¯ä¸ªè®¾å¤‡çš„ CS è„šè¢«è¿æ¥åˆ°å¤„ç†å™¨ç«¯ä¸åŒçš„ 
GPIOï¼Œé€šè¿‡æ“ä½œä¸åŒçš„  GPIO å£æ¥æ§åˆ¶å…·ä½“çš„éœ€è¦æ“ä½œçš„ SPI è®¾å¤‡ï¼Œå‡å°‘å„ä¸ª SPI è®¾
å¤‡é—´çš„å¹²æ‰°ã€‚

### SPI åè®®

SPI æ˜¯ä¸²è¡Œé€šè®¯åè®®ï¼Œä¹Ÿå°±æ˜¯è¯´æ•°æ®æ˜¯ä¸€ä½ä¸€ä½ä» MSB æˆ–è€… LSB å¼€å§‹ä¼ è¾“çš„ï¼Œè¿™å°±æ˜¯ 
SCK æ—¶é’Ÿçº¿å­˜åœ¨çš„åŸå› ï¼Œç”± SCK æä¾›æ—¶é’Ÿè„‰å†²ï¼ŒMISOã€MOSI åˆ™åŸºäºæ­¤è„‰å†²å®Œæˆæ•°æ®ä¼ 
è¾“ã€‚ SPI æ”¯æŒ 4-32bits çš„ä¸²è¡Œæ•°æ®ä¼ è¾“ï¼Œæ”¯æŒ MSB å’Œ LSBï¼Œæ¯æ¬¡æ•°æ®ä¼ è¾“æ—¶å½“ä»è®¾
å¤‡çš„å¤§å°ç«¯å‘ç”Ÿå˜åŒ–æ—¶éœ€è¦é‡æ–°è®¾ç½® SPI Master çš„å¤§å°ç«¯ã€‚

### SPI æ—¶é’Ÿæ¨¡å¼

SPI æ€»çº¿æœ‰å››ç§å·¥ä½œæ¨¡å¼ï¼Œå…¶ä¸­ä½¿ç”¨çš„æœ€ä¸ºå¹¿æ³›çš„æ˜¯ SPI0 å’Œ SPI3 æ–¹å¼ï¼ˆå®çº¿è¡¨ç¤ºï¼‰

![SPI0](https://raw.githubusercontent.com/EmulateSpace/PictureSet/master/BiscuitOS/kernel/DEV000073.png)

![SPI1](https://raw.githubusercontent.com/EmulateSpace/PictureSet/master/BiscuitOS/kernel/DEV000074.png)

å››ç§å·¥ä½œæ–¹å¼æ—¶åºåˆ†åˆ«ä¸ºï¼š

![SPI2](https://raw.githubusercontent.com/EmulateSpace/PictureSet/master/BiscuitOS/kernel/DEV000075.png)

#### æ—¶åºè¯¦è§£

> 1. CPOLï¼šæ—¶é’Ÿææ€§é€‰æ‹©ï¼Œä¸º 0 æ—¶ SPI æ€»çº¿ç©ºé—²ä¸ºä½ç”µå¹³ï¼Œä¸º 1 æ—¶ SPI æ€»çº¿ç©ºé—²ä¸º
>    é«˜ç”µå¹³
> 2. CPHAï¼šæ—¶é’Ÿç›¸ä½é€‰æ‹©ï¼Œä¸º 0 æ—¶åœ¨ SCK ç¬¬ä¸€ä¸ªè·³å˜æ²¿é‡‡æ ·ï¼Œä¸º 1 æ—¶åœ¨ SCK ç¬¬äºŒä¸ª
>    è·³å˜æ²¿é‡‡æ ·

#### å·¥ä½œæ–¹å¼ 1

å½“ CPHA=0ã€CPOL=0 æ—¶SPIæ€»çº¿å·¥ä½œåœ¨æ–¹å¼1ã€‚MISOå¼•è„šä¸Šçš„æ•°æ®åœ¨ç¬¬ä¸€ä¸ªSPSCKæ²¿è·³å˜ä¹‹
å‰å·²ç»ä¸Šçº¿äº†ï¼Œè€Œä¸ºäº†ä¿è¯æ­£ç¡®ä¼ è¾“ï¼ŒMOSIå¼•è„šçš„MSBä½å¿…é¡»ä¸SPSCKçš„ç¬¬ä¸€ä¸ªè¾¹æ²¿åŒæ­¥ï¼Œ
åœ¨SPIä¼ è¾“è¿‡ç¨‹ä¸­ï¼Œé¦–å…ˆå°†æ•°æ®ä¸Šçº¿ï¼Œç„¶ååœ¨åŒæ­¥æ—¶é’Ÿä¿¡å·çš„ä¸Šå‡æ²¿æ—¶ï¼ŒSPIçš„æ¥æ”¶æ–¹æ•æ‰
ä½ä¿¡å·ï¼Œåœ¨æ—¶é’Ÿä¿¡å·çš„ä¸€ä¸ªå‘¨æœŸç»“æŸæ—¶ï¼ˆä¸‹é™æ²¿ï¼‰ï¼Œä¸‹ä¸€ä½æ•°æ®ä¿¡å·ä¸Šçº¿ï¼Œå†é‡å¤ä¸Šè¿°è¿‡
ç¨‹ï¼Œç›´åˆ°ä¸€ä¸ªå­—èŠ‚çš„8ä½ä¿¡å·ä¼ è¾“ç»“æŸã€‚

#### å·¥ä½œæ–¹å¼ 2

å½“ CPHA=0ã€CPOL=1 æ—¶SPIæ€»çº¿å·¥ä½œåœ¨æ–¹å¼2ã€‚ä¸å‰è€…å”¯ä¸€ä¸åŒä¹‹å¤„åªæ˜¯åœ¨åŒæ­¥æ—¶é’Ÿä¿¡å·çš„
ä¸‹é™æ²¿æ—¶æ•æ‰ä½ä¿¡å·ï¼Œä¸Šå‡æ²¿æ—¶ä¸‹ä¸€ä½æ•°æ®ä¸Šçº¿ã€‚

#### å·¥ä½œæ–¹å¼ 3

å½“ CPHA=1ã€CPOL=0 æ—¶ SPI æ€»çº¿å·¥ä½œåœ¨æ–¹å¼3ã€‚MISOå¼•è„šå’ŒMOSIå¼•è„šä¸Šçš„æ•°æ®çš„MSBä½å¿…
é¡»ä¸SPSCKçš„ç¬¬ä¸€ä¸ªè¾¹æ²¿åŒæ­¥ï¼Œåœ¨SPIä¼ è¾“è¿‡ç¨‹ä¸­ï¼Œåœ¨åŒæ­¥æ—¶é’Ÿä¿¡å·å‘¨æœŸå¼€å§‹æ—¶ï¼ˆä¸Šå‡æ²¿ï¼‰
æ•°æ®ä¸Šçº¿ï¼Œç„¶ååœ¨åŒæ­¥æ—¶é’Ÿä¿¡å·çš„ä¸‹é™æ²¿æ—¶ï¼ŒSPIçš„æ¥æ”¶æ–¹æ•æ‰ä½ä¿¡å·ï¼Œåœ¨æ—¶é’Ÿä¿¡å·çš„ä¸€
ä¸ªå‘¨æœŸç»“æŸæ—¶ï¼ˆä¸Šå‡æ²¿ï¼‰ï¼Œä¸‹ä¸€ä½æ•°æ®ä¿¡å·ä¸Šçº¿ï¼Œå†é‡å¤ä¸Šè¿°è¿‡ç¨‹ï¼Œç›´åˆ°ä¸€ä¸ªå­—èŠ‚çš„8ä½
ä¿¡å·ä¼ è¾“ç»“æŸã€‚

#### å·¥ä½œæ–¹å¼ 4

å½“CPHA=1ã€CPOL=1æ—¶SPIæ€»çº¿å·¥ä½œåœ¨æ–¹å¼4ã€‚ä¸å‰è€…å”¯ä¸€ä¸åŒä¹‹å¤„åªæ˜¯åœ¨åŒæ­¥æ—¶é’Ÿä¿¡å·çš„ä¸Š
å‡æ²¿æ—¶æ•æ‰ä½ä¿¡å·ï¼Œä¸‹é™æ²¿æ—¶ä¸‹ä¸€ä½æ•°æ®ä¸Šçº¿ã€‚

--------------------------------------------------

# <span id="Uboot ä¸­æºç æˆ–å·¥å…·è®¿é—® SPI">Uboot ä¸­è®¿é—® SPI</span>

å¼€å‘è€…åœ¨ Uboot é˜¶æ®µå¯ä»¥é€šè¿‡ä¸¤ç§æ–¹å¼è®¿é—® SPI ä»è®¾å¤‡ã€‚åˆ†åˆ«æ˜¯ï¼š

> 1. [å·¥å…·è®¿é—® SPI](#å·¥å…·è®¿é—® SPI)
>
> 2. [æºç è®¿é—® SPI](#æºç è®¿é—® SPI)

## <span id="å·¥å…·è®¿é—® SPI">å·¥å…·è®¿é—® SPI</span>

åœ¨ Uboot å‘½ä»¤è¡Œæ¨¡å¼ä¸‹ï¼Œç³»ç»Ÿæä¾›äº† sf å·¥å…·æ¥æ“ä½œ SPI-Flashã€‚é€šè¿‡è¿™ä¸ªå·¥å…·å¯ä»¥è¿›
è¡Œ SPI-Flash çš„è¯»ï¼Œå†™ï¼Œæ“¦é™¤ï¼Œå’Œæ›´æ–°æ“ä½œã€‚å·¥å…·çš„ä½¿ç”¨æ–¹æ³•å¦‚ä¸‹ï¼š

{% highlight ruby %}
ZynqMP> sf
sf - SPI flash sub-system

Usage:
sf probe [[bus:]cs] [hz] [mode] - init flash device on given SPI bus
                                  and chip select
sf read addr offset|partition len       - read `len' bytes starting at
                                          `offset' or from start of mtd
                                          `partition'to memory at `addr'
sf write addr offset|partition len      - write `len' bytes from memory
                                          at `addr' to flash at `offset'
                                          or to start of mtd `partition'
sf erase offset|partition [+]len        - erase `len' bytes from `offset'
                                          or from start of mtd `partition'
                                         `+len' round up `len' to block size
sf update addr offset|partition len     - erase and write `len' bytes from memoy
                                          at `addr' to flash at `offset'
                                          or to start of mtd `partition'
sf protect lock/unlock sector len       - protect/unprotect 'len' bytes starting
                                          at address 'sector'

ZynqMP>
{% endhighlight %}

#### åˆå§‹åŒ– SPI-Flash

**sf probe** å‘½ä»¤ç”¨äºåˆå§‹åŒ– SPI-Flash æ§åˆ¶å™¨ï¼Œä½¿ç”¨æ¨¡å¼å¦‚ä¸‹ï¼š

{% highlight ruby %}
sf probe [[bus:]cs] [hz] [mode]
{% endhighlight %}

ä¾‹å¦‚ï¼Œæ¢æµ‹å¹¶åˆå§‹åŒ–ç³»ç»Ÿå¯ç”¨çš„ SPI-Flashï¼š

{% highlight ruby %}
ZynqMP> sf probe
SF: Detected n25q256a with page size 512 Bytes, erase size 128 KiB, total 64 MiB
ZynqMP>
{% endhighlight %}

#### SPI-Flash è¯»

**sf read** å‘½ä»¤ç”¨äºä» SPI-Flash çš„ç‰¹å®šä½ç½®ä¸Šï¼Œè¯»ä¸€å®šé•¿åº¦çš„æ•°æ®åˆ°å†…å­˜æŒ‡å®šä½ç½®
ä¸Šã€‚ä½¿ç”¨æ ¼å¼å¦‚ä¸‹ï¼š

{% highlight ruby %}
sf read addr offset|partition len
{% endhighlight %}

ä¾‹å¦‚ï¼Œä» SPI-Flash 0x100 çš„ä½ç½®ä¸Šï¼Œè¯»å– 0x2000 ä¸ªå­—èŠ‚åˆ°å†…å­˜çš„ 0x40000 ä½ç½®ä¸Šï¼š

{% highlight ruby %}
ZynqMP> sf read 0x40000 0x100 0x2000
device 0 offset 0x100, size 0x2000
SF: 8192 bytes @ 0x100 Read: OK
ZynqMP>
{% endhighlight %}

#### SPI-Flash å†™

**sf write** å‘½ä»¤ç”¨äºä»å†…å­˜æŒ‡å®šä½ç½®ï¼Œå†™ä¸€å®šé•¿åº¦çš„æ•°æ®åˆ° SPI-Flash çš„æŒ‡å®šä½ç½®
ä¸Šï¼Œä½¿ç”¨æ ¼å¼å¦‚ä¸‹ï¼š

{% highlight ruby %}
sf write addr offset|partition len
{% endhighlight %}

ä¾‹å¦‚ï¼Œä»å†…å­˜ 0x40000 å¤„ï¼Œå†™ 0x10 å­—èŠ‚åˆ° SPI-Flash 0x3F00000 ä½ç½®ä¸Šï¼š

{% highlight ruby %}
ZynqMP> sf write 0x40000 0x3F00000 0x10
device 0 offset 0x3f00000, size 0x10
SF: 16 bytes @ 0x3f00000 Written: OK
ZynqMP>
{% endhighlight %}

#### SPI-Flash æ“¦é™¤

**sf erase** å‘½ä»¤ç”¨äºæ“¦é™¤ SPI-Flash ä¸Šä¸€æ®µå†…å®¹ï¼Œä½¿ç”¨æ ¼å¼å¦‚ä¸‹ï¼š

{% highlight ruby %}
sf erase offset|partition [+]len
{% endhighlight %}

ä¾‹å¦‚ï¼Œæ“¦é™¤ SPI-Flash 0x3F00000 å¼€å§‹å¤„ï¼Œé•¿åº¦ä¸º 0x100000 å­—èŠ‚çš„æ•°æ®

{% highlight ruby %}
ZynqMP> sf erase 0x3f00000 0x100000
SF: 1048576 bytes @ 0x3f00000 Erased: OK
ZynqMP>
{% endhighlight %}

#### SPI-Fash æ›´æ–°

**sf update** å‘½ä»¤ç”¨äºæ›´æ–° SPI-Flash ä¸ŠæŒ‡å®šåŒºåŸŸå†…çš„æ•°æ®ï¼Œå¯¹æ¯”æ•°æ®åœ¨å†…å­˜çš„æŒ‡å®š
ä½ç½®ä¸Šï¼Œä½¿ç”¨æ¨¡å¼å¦‚ä¸‹ï¼š

{% highlight ruby %}
sf update addr offset|partition len
{% endhighlight %}

ä¾‹å¦‚ï¼Œå°†å†…æ ¸ 0x400 å¤„ 0x10 ä¸ªå­—èŠ‚æ›´æ–°åˆ° SPI-Flash 0x3F00000 å¼€å§‹çš„åœ°å€ï¼š

{% highlight ruby %}
ZynqMP> sf update 0x4000 0x3F00000 0x10
device 0 offset 0x3f00000, size 0x10
16 bytes written, 0 bytes skipped in 0.41s, speed 372 B/s
ZynqMP>
{% endhighlight %}

## <span id="æºç è®¿é—® SPI">æºç è®¿é—® SPI</span>

å¼€å‘è€…ä¹Ÿå¯ä»¥é€šè¿‡æºç åœ¨ Uboot ä¸­è®¿é—® SPIï¼Œå¯ä»¥å‚è€ƒå¦‚ä¸‹ä»£ç ï¼š

{% highlight ruby %}
/*
* SPI read/write on Uboot
*
* (C) 2018.11.18 BiscuitOS <buddy.zhang@aliyun.com>
*
* This program is free software; you can redistribute it and/or modify
* it under the terms of the GNU General Public License version 2 as
* published by the Free Software Foundation.
*/
#include <common.h>
#include <spi.h>

/* Init slave device */
struct spi_slave *spi_slave_init(void)
{
    struct spi_slave *slave;
    unsigned int bus = 0;
    unsigned int cs  = 2;
    unsigned int mode = SPI_MODE_0;

    slave = spi_setup_slave(bus, cs, 1000000, mode);
    if (!slave) {
        printf("Invalid device %d:%d\n", bus, cs);
        return NULL;
    }

    spi_claim_bus(slave);

    return slave;
}

/* SPI read/write operation */
static int spi_read_write(struct spi_slave *spi, const u8 *cmd,
                    size_t cmd_len, const u8 *data_out, size_t data_len)
{
    unsigned long flags = SPI_XFER_BEGIN;
    int ret;

    if (data_len == 0)
        flags |= SPI_XFER_END;

    ret = spi_xfer(spi, cmd_len * 8, cmd, NULL, flags);
    if (ret) {
        printf("Invalid send command\n");
    } else if (data_len != 0) {
        ret = spi_xfer(spi, data_len * 8, data_out, data_on, SPI_XFER_END);
        if (ret)
            printf("Incalid transfer data\n");
    }

    return ret;
}
{% endhighlight %}

----------------------------------------

# <span id="Kernel ä¸­æºç è®¿é—® SPI">Kernel ä¸­è®¿é—® SPI</span>

å†…æ ¸ä¸­è¦èƒ½è®¿é—® SPIï¼Œéœ€è¦å‡†å¤‡ä»¥ä¸‹å‡ ä¸ªå†…å®¹

> 1. [SPI è®¾å¤‡é©±åŠ¨](#SPI è®¾å¤‡é©±åŠ¨)
>
> 2. [SPI è®¾å¤‡åœ¨ DTS ä¸­æè¿°](#SPI è®¾å¤‡åœ¨ DTS ä¸­æè¿°)
> 
> 3. [SPI ç›¸å…³å®](#SPI ç›¸å…³å®)

### <span id="SPI è®¾å¤‡é©±åŠ¨">SPI è®¾å¤‡é©±åŠ¨</span>

SPI è®¾å¤‡é©±åŠ¨ï¼Œå¼€å‘è€…å¯ä»¥å‚è€ƒå¦‚ä¸‹ï¼š

{% highlight ruby %}
/*
* SPI read/write on Kernel
*
* (C) 2018.11.19 BuddyZhang1 <buddy.zhang@aliyun.com>
*
* This program is free software; you can redistribute it and/or modify
* it under the terms of the GNU General Public License version 2 as
* published by the Free Software Foundation.
*/
#include <linux/kernel.h>
#include <linux/init.h>
#include <linux/module.h>
#include <linux/spi/spi.h>
#include <linux/spi/spidev.h>
#include <linux/of.h>
#include <linux/of_device.h>

/*
* SPI device on DTS
*
* &spi0 {
*     status = "okay";
*     
*     spi_demo@2 {
*         compatible = "spi_demo";
*         #address-cells = <1>;
*         #size-cells = <1>;
*         reg = <0x2>;
*         spi-max-frequency = <5000000>;
*     };
* };
*/

#define DEV_NAME                "spi_demo"
#define SPI_TRANSFER_BUF_LEN    14

/* SPI interface instruction set */
#define INSTRUCTION_WRITE       0x02
#define INSTRUCTION_READ        0x03
#define INSTRUCTION_BIT_MODIFY  0x05

struct spi_demo_priv {
    struct spi_device *spi;

    u8 *spi_tx_buf;
    u8 *spi_rx_buf;
};

static int spi_demo_trans(struct spi_device *spi, int len)
{
    struct spi_demo_priv *priv = spi_get_drvdata(spi);
    struct spi_transfer t = {
        .tx_buf = priv->spi_tx_buf,
        .rx_buf = priv->spi_rx_buf,
        .len    = len,
        .cs_change = 0,
    };
    struct spi_message msg;
    int ret;

    spi_message_init(&msg);

    spi_message_add_tail(&t, &msg);

    ret = spi_sync(spi, &msg);
    if (ret)
        printk(KERN_ERR "spi transfer failed, ret = %d\n", ret);
    return ret;
}

/*
* Read one byte from SPI slave device
*  @spi: spi slave device
*  @reg: register need to read.
*
* if succeed, return the value of register.
*/
static u8 spi_demo_read_reg(struct spi_device *spi, uint8_t reg)
{
    struct spi_demo_priv *priv = spi_get_drvdata(spi);
    u8 val = 0;

    priv->spi_tx_buf[0] = INSTRUCTION_READ;
    priv->spi_tx_buf[1] = reg;

    spi_demo_trans(spi, 3);
    val = priv->spi_rx_buf[2];

    return val;
}

/*
* Read two byte from SPI slave device
*  @spi: SPi slave device.
*  @reg: register need to read.
*
* if succeed, v1 is first registe's value and v2 is second register's value.
*/
static void spi_demo_read_2regs(struct spi_device *spi, uint8_t reg,
                            uint8_t *v1, uint8_t *v2)
{
    struct spi_demo_priv *priv = spi_get_drvdata(spi);

    priv->spi_tx_buf[0] = INSTRUCTION_READ;
    priv->spi_tx_buf[1] = reg;

    spi_demo_trans(spi, 4);

    *v1 = priv->spi_rx_buf[2];
    *v2 = priv->spi_rx_buf[3];
}

/*
* Write one byte to SPI slave device
*  @spi: SPI slave device
*  @reg: Regsiter need to write
*  @val: data need to write.
*/
static void spi_demo_write_reg(struct spi_device *spi, u8 reg, uint8_t val)
{
    struct spi_demo_priv *priv = spi_get_drvdata(spi);

    priv->spi_tx_buf[0] = INSTRUCTION_WRITE;
    priv->spi_tx_buf[1] = reg;
    priv->spi_tx_buf[2] = val;

    spi_demo_trans(spi, 3);
}

/*
* Change speical bit on SPI slave device.
*  @spi: SPI slave device.
*  @reg: register need to write.
*  @mask: mask for modify.
*  @val: data need to write.
*/
static void spi_demo_write_bits(struct spi_device *spi, u8 reg,
                                   u8 mask, uint8_t val)
{
    struct spi_demo_priv *priv = spi_get_drvdata(spi);

    priv->spi_tx_buf[0] = INSTRUCTION_BIT_MODIFY;
    priv->spi_tx_buf[1] = reg;
    priv->spi_tx_buf[2] = mask;
    priv->spi_tx_buf[3] = val;

    spi_demo_trans(spi, 4);
}

/*
* SPI Slave device probe entence
*/
static int spi_demo_probe(struct spi_device *spi)
{
    struct spi_demo_priv priv;
    int value;

    spi_set_drvdata(spi, &priv);

    /* Configure the SPI bus */
    spi->bits_per_word = 8;
    spi->max_speed_hz = spi->max_speed_hz ? : 10 * 1000 * 1000;

    /* Power up SPI slave device */

    spi_setup(spi);

    /* Allocate non-DMA buffers */
    priv.spi_tx_buf = devm_kzalloc(&spi->dev, SPI_TRANSFER_BUF_LEN,
                                          GFP_KERNEL);
    priv.spi_rx_buf = devm_kzalloc(&spi->dev, SPI_TRANSFER_BUF_LEN,
                                          GFP_KERNEL);

    /* Read data from SPI slave device */
    value = spi_demo_read_reg(spi, 0x10);

    /* Write data into SPI slave device */
    spi_demo_write_reg(spi, 0x10, value);

    return 0;
}

/*
* SPI Slave device remove entence
*/
static int spi_demo_remove(struct spi_device *spi)
{
    /* Power off SPI slave device */

    return 0;
}

static const struct of_device_id spi_demo_dt_ids[] = {
    { .compatible = DEV_NAME },
    { },
};

static const struct spi_device_id spi_demo_id[] = {
    { DEV_NAME },
    { }
};

MODULE_DEVICE_TABLE(spi, spi_demo_id);

static struct spi_driver spi_demo_driver = {
    .driver = {
        .name  = DEV_NAME,
        .owner = THIS_MODULE,
        .of_match_table = of_match_ptr(spi_demo_dt_ids),
    },
    .probe    = spi_demo_probe,
    .remove   = spi_demo_remove,
    .id_table = spi_demo_id,
};

module_spi_driver(spi_demo_driver);

MODULE_LICENSE("GPL v2");
MODULE_ALIAS("spi demo");
{% endhighlight %}

Makefile

{% highlight ruby %}
obj-m += spi.o

KERNELDIR ?= /lib/modules/$(shell uname -r)/build

PWD       := $(shell pwd)

ROOT := $(dir $(M))
DEMOINCLUDE := -I$(ROOT)../include -I$(ROOT)/include

GCCVERSION = $(shell gcc -dumpversion | sed -e 's/\.\([0-9][0-9]\)/\1/g' -e 's/\.\([0-9]\)/0\1/g' -e 's/^[0-9]\{3,4\}$$/&00/')

GCC49 := $(shell expr $(GCCVERSION) \>= 40900)

all:
        $(MAKE) -C $(KERNELDIR) M=$(PWD) modules

install: all
        $(MAKE) -C $(KERNELDIR) M=$(PWD) modules_install
        depmod -a

clean:
        rm -rf *.o *.o.d *~ core .depend .*.cmd *.ko *.ko.unsigned *.mod.c .tmp_versions *.symvers \
        .cache.mk *.save *.bak Modules.* modules.order Module.markers *.bin

CFLAGS_spi.o := -Wall $(DEMOINCLUDE)

ifeq ($(GCC49),1)
        CFLAGS_spi.o += -Wno-error=date-time
endif

CFLAGS_spi.o := $(DEMOINCLUDE)
{% endhighlight %}

SPI é©±åŠ¨å¯ä»¥åŠ è½½åˆ°å†…æ ¸ä¹Ÿå¯ä»¥å¤–éƒ¨ç¼–è¯‘ï¼Œç¼–è¯‘å‘½ä»¤å¦‚ä¸‹ï¼š

{% highlight ruby %}
make clean
make
sudo insmod spi.ko
{% endhighlight %}

### <span id="SPI è®¾å¤‡åœ¨ DTS ä¸­æè¿°">SPI è®¾å¤‡åœ¨ DTS ä¸­çš„æè¿°</span>

å‡†å¤‡å¥½é©±åŠ¨ä¹‹åï¼Œæ¥ä¸‹æ¥éœ€è¦åœ¨ DTS ä¸­æ·»åŠ  SPI è®¾å¤‡çš„æè¿°ã€‚å¼€å‘è€…å¯ä»¥å‚è€ƒå¦‚ä¸‹ï¼š

{% highlight ruby %}
&spi0 {
    status = "okay";
    
    spi_demo@2 {
        compatible = "spi_demo";
        #address-cells = <1>;
        #size-cells = <1>;
        reg = <0x2>;
        spi-max-frequency = <5000000>;
    };
};
{% endhighlight %}

### <span id="SPI ç›¸å…³å®">SPI ç›¸å…³çš„å®</span>

ä¸ºäº†èƒ½åœ¨ç³»ç»Ÿä¸­è¿è¡Œ SPI è®¾å¤‡é©±åŠ¨ï¼Œè¯·ç¡®ä¿å†…æ ¸å·²ç»æ‰“å¼€å¦‚ä¸‹å®ï¼š

{% highlight ruby %}
CONFIG_SPI=y
CONFIG_SPI_MASTER=y
CONFIG_SPI_ORION=y
{% endhighlight %}

----------------------------------------------

# <span id="ç”¨æˆ·ç©ºé—´ä¸­æºç æˆ–å·¥å…·è®¿é—® SPI">ç”¨æˆ·ç©ºé—´è®¿é—® SPI</span>

ç”¨æˆ·ç©ºé—´ä¹Ÿå¯ä»¥é€šè¿‡ä¸¤ç§æ–¹å¼è®¿é—® SPIï¼Œåˆ†åˆ«å¦‚ä¸‹ï¼š

> 1. [ä½¿ç”¨å·¥å…·è®¿é—® SPI](#ä½¿ç”¨å·¥å…·è®¿é—® SPI)
>
> 2. [ç”¨æˆ·ç¨‹åºè®¿é—® SPI](#ç”¨æˆ·ç¨‹åºè®¿é—® SPI)

### <span id="ä½¿ç”¨å·¥å…·è®¿é—® SPI">ä½¿ç”¨å·¥å…·è®¿é—® SPI</span>

Linux ç”¨æˆ·ç©ºé—´æœ‰å¤šç§ SPI å·¥å…·ï¼Œè¿™é‡Œä»‹ç» spi-tools, è¿™ä¸ªå·¥å…·å¯ä»¥é€šè¿‡ busybox æ
ä¾›æˆ–ç›´æ¥æºç ç¼–è¯‘ä½¿ç”¨ã€‚å…·ä½“ä½¿ç”¨æ­¥éª¤å¦‚ä¸‹ï¼š

{% highlight ruby %}
git clone https://github.com/msperl/spi-config.git
cd spi-config/
make
make install
{% endhighlight %}

ä½¿ç”¨æ ¼å¼ï¼š

{% highlight ruby %}
modprobe spi-config devices=<devicedev1>,<devicedev2>,...,<devicedev16>
{% endhighlight %}

ä¾‹å¦‚ï¼š

{% highlight ruby %}
modprobe spi-config devices=\
bus=0:cs=0:modalias=mcp2515:speed=10000000:gpioirq=25:pd=20:pdu32-0=16000000:pdu32-4=0x2002,\
bus=0:cs=1:modalias=mcp2515:speed=6000000:gpioirq=22:pd=0x14:pdu32-0=20000000:pdu32-4=0x02
{% endhighlight %}

è¯¦ç»†æ­¥éª¤ï¼Œè¯·æŸ¥çœ‹ githubï¼š

> https://github.com/BiscuitOS/HardStack/blob/master/bus/spi/user/README.md

## <span id="ç”¨æˆ·ç¨‹åºè®¿é—® SPI">æºç è®¿é—® SPI</span>

é€šè¿‡æºç åœ¨ç”¨æˆ·ç©ºé—´è®¿é—® SPIï¼Œå¼€å‘è€…å¯ä»¥å‚è€ƒå¦‚ä¸‹ä»£ç ï¼š

{% highlight ruby %}
/*
* SPI testing utility (using spidev driver)
*
* Copyright (c) 2007  MontaVista Software, Inc.
* Copyright (c) 2007  Anton Vorontsov
*
* This program is free software; you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation; either version 2 of the License.
*
* Cross-compile with cross-gcc -I/path/to/cross-kernel/include
*
*/
#include <stdint.h>
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include <getopt.h>
#include <fcntl.h>
#include <sys/ioctl.h>
#include <linux/types.h>
#include <linux/spi/spidev.h>

#define ARRAY_SIZE(a) (sizeof(a) / sizeof((a)[0]))

static void pabort(const char *s)
{
    perror(s);
    abort();
}

static const char *device = "/dev/spidev1.1";
static uint8_t mode = 3;
static uint8_t bits = 8;
static uint32_t speed = 1000000;
static uint16_t delay;

static void transfer(int fd)
{
    int ret;
    uint8_t tx[] = {
                0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                0x40, 0x00, 0x00, 0x00, 0x00, 0x95,
                0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                0xDE, 0xAD, 0xBE, 0xEF, 0xBA, 0xAD,
                0xF0, 0x0D,
    };
    uint8_t rx[ARRAY_SIZE(tx)] = {0, };
    struct spi_ioc_transfer tr = {
        .tx_buf = (unsigned long)tx,
        .rx_buf = (unsigned long)rx,
        .len = ARRAY_SIZE(tx),
        .delay_usecs = delay,
        .speed_hz = 0,
        .bits_per_word = 0,
    };

    ret = ioctl(fd, SPI_IOC_MESSAGE(1), &tr);
    if (ret == 1)
        pabort("can't send spi message");

    for (ret = 0; ret < ARRAY_SIZE(tx); ret++) {
        if (!(ret % 6))
            puts("");
        printf("%.2X ", rx[ret]);
    }
    puts("");
}

void print_usage(const char *prog)
{
    printf("Usage: %s [-DsbdlHOLC3]\n", prog);
    puts("  -D --device   device to use (default /dev/spidev1.1)\n"
         "  -s --speed    max speed (Hz)\n"
         "  -d --delay    delay (usec)\n"
         "  -b --bpw      bits per word \n"
         "  -l --loop     loopback\n"
         "  -H --cpha     clock phase\n"
         "  -O --cpol     clock polarity\n"
         "  -L --lsb      least significant bit first\n"
         "  -C --cs-high  chip select active high\n"
         "  -3 --3wire    SI/SO signals shared\n");
    exit(1);
}

void parse_opts(int argc, char *argv[])
{
    while (1) {
        static const struct option lopts[] = {
            { "device",  1, 0, 'D' },
            { "speed",   1, 0, 's' },
            { "delay",   1, 0, 'd' },
            { "bpw",     1, 0, 'b' },
            { "loop",    0, 0, 'l' },
            { "cpha",    0, 0, 'H' },
            { "cpol",    0, 0, 'O' },
            { "lsb",     0, 0, 'L' },
            { "cs-high", 0, 0, 'C' },
            { "3wire",   0, 0, '3' },
            { NULL, 0, 0, 0 },
        };
        int c;

        c = getopt_long(argc, argv, "D:s:d:b:lHOLC3", lopts, NULL);
        if (c == -1)
            break;
        switch (c) {
        case 'D':
            device = optarg;
            break;
        case 's':
            speed = atoi(optarg);
            break;
        case 'd':
            delay = atoi(optarg);
            break;
        case 'b':
            bits = atoi(optarg);
            break;
        case 'l':
            mode |= SPI_LOOP;
            break;
        case 'H':
            mode |= SPI_CPHA;
            break;
        case 'O':
            mode |= SPI_CPOL;
            break;
        case 'L':
            mode |= SPI_LSB_FIRST;
            break;
        case 'C':
            mode |= SPI_CS_HIGH;
            break;
        case '3':
            mode |= SPI_3WIRE;
            break;
        default:
            print_usage(argv[0]);
            break;
        }
    }
}

int main(int argc, char *argv[])
{
    int ret = 0;
    int fd;

    parse_opts(argc, argv);
    fd = open(device, O_RDWR);
    if (fd < 0)
        pabort("can't open device");

    /* spi mode */
    ret = ioctl(fd, SPI_IOC_WR_MODE, &mode);
    if (ret == -1)
        pabort("can't set spi mode");

    ret = ioctl(fd, SPI_IOC_RD_MODE, &mode);
    if (ret == -1)
        pabort("can't get spi mode");

    /* bits per word */
    ret = ioctl(fd, SPI_IOC_WR_BITS_PER_WORD, &bits);
    if (ret == -1)
        pabort("can't set bits per word");

    ret = ioctl(fd, SPI_IOC_RD_BITS_PER_WORD, &bits);
    if (ret == -1)
        pabort("can't get bits per word");

    /* max speed hz */
    ret = ioctl(fd, SPI_IOC_WR_MAX_SPEED_HZ, &speed);
    if (ret == -1)
        pabort("can't set max speed hz");

    ret = ioctl(fd, SPI_IOC_RD_MAX_SPEED_HZ, &speed);
    if (ret == -1)
        pabort("can't get max speed hz");

    printf("spi mode: %d\n", mode);
    printf("bits per word: %d\n", bits);
    printf("max speed: %d Hz (%d KHz)\n", speed, speed/1000);

    transfer(fd);

    close(fd);

    return ret;
}
{% endhighlight %}

----------------------------------------------

# <span id="SPI ç¡¬ä»¶ä¿¡å·æµ‹è¯•">SPI ç¡¬ä»¶æ³¢å½¢æµ‹è¯•</span>

SPI è¯»å†™åè®®

SPI è¯»æ³¢å½¢å›¾

![SPI2](https://raw.githubusercontent.com/EmulateSpace/PictureSet/master/BiscuitOS/kernel/DEV000076.png)

SPI è¯»å®æµ‹æ³¢å½¢å›¾

![SPI2](https://raw.githubusercontent.com/EmulateSpace/PictureSet/master/BiscuitOS/kernel/DEV000077.png)

SPI å†™æ³¢å½¢å›¾

![SPI2](https://raw.githubusercontent.com/EmulateSpace/PictureSet/master/BiscuitOS/kernel/DEV000078.png)

SPI å®é™…æµ‹è¯•æ³¢å½¢å›¾

![SPI2](https://raw.githubusercontent.com/EmulateSpace/PictureSet/master/BiscuitOS/kernel/DEV000079.png)

------------------------------------------------

# <span id="é™„å½•">é™„å½•</span>

> [Using SPI with Linux](https://armbedded.taskit.de/node/318)
>
> [Serial Peripheral Interface](https://en.wikipedia.org/wiki/Serial_Peripheral_Interface)
>
> [BiscuitOS Home](https://biscuitos.github.io/)
>
> [BiscuitOS Driver](https://biscuitos.github.io/blog/BiscuitOS_Catalogue/)
>
> [BiscuitOS Kernel Build](https://biscuitos.github.io/blog/Kernel_Build/)
>
> [Linux Kernel](https://www.kernel.org/)
>
> [Bootlin: Elixir Cross Referencer](https://elixir.bootlin.com/linux/latest/source)

## èµèµä¸€ä¸‹å§ ğŸ™‚

![MMU](https://raw.githubusercontent.com/EmulateSpace/PictureSet/master/BiscuitOS/kernel/HAB000036.jpg)
